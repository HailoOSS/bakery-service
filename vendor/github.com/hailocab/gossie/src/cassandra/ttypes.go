// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cassandra

import (
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf

var GoUnusedProtection__ int

//The ConsistencyLevel is an enum that controls both read and write
//behavior based on the ReplicationFactor of the keyspace.  The
//different consistency levels have different meanings, depending on
//if you're doing a write or read operation.
//
//If W + R > ReplicationFactor, where W is the number of nodes to
//block for on write, and R the number to block for on reads, you
//will have strongly consistent behavior; that is, readers will
//always see the most recent write. Of these, the most interesting is
//to do QUORUM reads and writes, which gives you consistency while
//still allowing availability in the face of node failures up to half
//of <ReplicationFactor>. Of course if latency is more important than
//consistency then you can use lower values for either or both.
//
//Some ConsistencyLevels (ONE, TWO, THREE) refer to a specific number
//of replicas rather than a logical concept that adjusts
//automatically with the replication factor.  Of these, only ONE is
//commonly used; TWO and (even more rarely) THREE are only useful
//when you care more about guaranteeing a certain level of
//durability, than consistency.
//
//Write consistency levels make the following guarantees before reporting success to the client:
//  ANY          Ensure that the write has been written once somewhere, including possibly being hinted in a non-target node.
//  ONE          Ensure that the write has been written to at least 1 node's commit log and memory table
//  TWO          Ensure that the write has been written to at least 2 node's commit log and memory table
//  THREE        Ensure that the write has been written to at least 3 node's commit log and memory table
//  QUORUM       Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes
//  LOCAL_QUORUM Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes, within the local datacenter (requires NetworkTopologyStrategy)
//  EACH_QUORUM  Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes in each datacenter (requires NetworkTopologyStrategy)
//  ALL          Ensure that the write is written to <code>&lt;ReplicationFactor&gt;</code> nodes before responding to the client.
//
//Read consistency levels make the following guarantees before returning successful results to the client:
//  ANY          Not supported. You probably want ONE instead.
//  ONE          Returns the record obtained from a single replica.
//  TWO          Returns the record with the most recent timestamp once two replicas have replied.
//  THREE        Returns the record with the most recent timestamp once three replicas have replied.
//  QUORUM       Returns the record with the most recent timestamp once a majority of replicas have replied.
//  LOCAL_QUORUM Returns the record with the most recent timestamp once a majority of replicas within the local datacenter have replied.
//  EACH_QUORUM  Returns the record with the most recent timestamp once a majority of replicas within each datacenter have replied.
//  ALL          Returns the record with the most recent timestamp once all replicas have replied (implies no replica may be down)..
type ConsistencyLevel int64

const (
	ConsistencyLevel_ONE          ConsistencyLevel = 1
	ConsistencyLevel_QUORUM       ConsistencyLevel = 2
	ConsistencyLevel_LOCAL_QUORUM ConsistencyLevel = 3
	ConsistencyLevel_EACH_QUORUM  ConsistencyLevel = 4
	ConsistencyLevel_ALL          ConsistencyLevel = 5
	ConsistencyLevel_ANY          ConsistencyLevel = 6
	ConsistencyLevel_TWO          ConsistencyLevel = 7
	ConsistencyLevel_THREE        ConsistencyLevel = 8
)

func (p ConsistencyLevel) String() string {
	switch p {
	case ConsistencyLevel_ONE:
		return "ConsistencyLevel_ONE"
	case ConsistencyLevel_QUORUM:
		return "ConsistencyLevel_QUORUM"
	case ConsistencyLevel_LOCAL_QUORUM:
		return "ConsistencyLevel_LOCAL_QUORUM"
	case ConsistencyLevel_EACH_QUORUM:
		return "ConsistencyLevel_EACH_QUORUM"
	case ConsistencyLevel_ALL:
		return "ConsistencyLevel_ALL"
	case ConsistencyLevel_ANY:
		return "ConsistencyLevel_ANY"
	case ConsistencyLevel_TWO:
		return "ConsistencyLevel_TWO"
	case ConsistencyLevel_THREE:
		return "ConsistencyLevel_THREE"
	}
	return "<UNSET>"
}

func ConsistencyLevelFromString(s string) (ConsistencyLevel, error) {
	switch s {
	case "ConsistencyLevel_ONE":
		return ConsistencyLevel_ONE, nil
	case "ConsistencyLevel_QUORUM":
		return ConsistencyLevel_QUORUM, nil
	case "ConsistencyLevel_LOCAL_QUORUM":
		return ConsistencyLevel_LOCAL_QUORUM, nil
	case "ConsistencyLevel_EACH_QUORUM":
		return ConsistencyLevel_EACH_QUORUM, nil
	case "ConsistencyLevel_ALL":
		return ConsistencyLevel_ALL, nil
	case "ConsistencyLevel_ANY":
		return ConsistencyLevel_ANY, nil
	case "ConsistencyLevel_TWO":
		return ConsistencyLevel_TWO, nil
	case "ConsistencyLevel_THREE":
		return ConsistencyLevel_THREE, nil
	}
	return ConsistencyLevel(0), fmt.Errorf("not a valid ConsistencyLevel string")
}

func ConsistencyLevelPtr(v ConsistencyLevel) *ConsistencyLevel { return &v }

type IndexOperator int64

const (
	IndexOperator_EQ  IndexOperator = 0
	IndexOperator_GTE IndexOperator = 1
	IndexOperator_GT  IndexOperator = 2
	IndexOperator_LTE IndexOperator = 3
	IndexOperator_LT  IndexOperator = 4
)

func (p IndexOperator) String() string {
	switch p {
	case IndexOperator_EQ:
		return "IndexOperator_EQ"
	case IndexOperator_GTE:
		return "IndexOperator_GTE"
	case IndexOperator_GT:
		return "IndexOperator_GT"
	case IndexOperator_LTE:
		return "IndexOperator_LTE"
	case IndexOperator_LT:
		return "IndexOperator_LT"
	}
	return "<UNSET>"
}

func IndexOperatorFromString(s string) (IndexOperator, error) {
	switch s {
	case "IndexOperator_EQ":
		return IndexOperator_EQ, nil
	case "IndexOperator_GTE":
		return IndexOperator_GTE, nil
	case "IndexOperator_GT":
		return IndexOperator_GT, nil
	case "IndexOperator_LTE":
		return IndexOperator_LTE, nil
	case "IndexOperator_LT":
		return IndexOperator_LT, nil
	}
	return IndexOperator(0), fmt.Errorf("not a valid IndexOperator string")
}

func IndexOperatorPtr(v IndexOperator) *IndexOperator { return &v }

type IndexType int64

const (
	IndexType_KEYS   IndexType = 0
	IndexType_CUSTOM IndexType = 1
)

func (p IndexType) String() string {
	switch p {
	case IndexType_KEYS:
		return "IndexType_KEYS"
	case IndexType_CUSTOM:
		return "IndexType_CUSTOM"
	}
	return "<UNSET>"
}

func IndexTypeFromString(s string) (IndexType, error) {
	switch s {
	case "IndexType_KEYS":
		return IndexType_KEYS, nil
	case "IndexType_CUSTOM":
		return IndexType_CUSTOM, nil
	}
	return IndexType(0), fmt.Errorf("not a valid IndexType string")
}

func IndexTypePtr(v IndexType) *IndexType { return &v }

//CQL query compression
type Compression int64

const (
	Compression_GZIP Compression = 1
	Compression_NONE Compression = 2
)

func (p Compression) String() string {
	switch p {
	case Compression_GZIP:
		return "Compression_GZIP"
	case Compression_NONE:
		return "Compression_NONE"
	}
	return "<UNSET>"
}

func CompressionFromString(s string) (Compression, error) {
	switch s {
	case "Compression_GZIP":
		return Compression_GZIP, nil
	case "Compression_NONE":
		return Compression_NONE, nil
	}
	return Compression(0), fmt.Errorf("not a valid Compression string")
}

func CompressionPtr(v Compression) *Compression { return &v }

type CqlResultType int64

const (
	CqlResultType_ROWS CqlResultType = 1
	CqlResultType_VOID CqlResultType = 2
	CqlResultType_INT  CqlResultType = 3
)

func (p CqlResultType) String() string {
	switch p {
	case CqlResultType_ROWS:
		return "CqlResultType_ROWS"
	case CqlResultType_VOID:
		return "CqlResultType_VOID"
	case CqlResultType_INT:
		return "CqlResultType_INT"
	}
	return "<UNSET>"
}

func CqlResultTypeFromString(s string) (CqlResultType, error) {
	switch s {
	case "CqlResultType_ROWS":
		return CqlResultType_ROWS, nil
	case "CqlResultType_VOID":
		return CqlResultType_VOID, nil
	case "CqlResultType_INT":
		return CqlResultType_INT, nil
	}
	return CqlResultType(0), fmt.Errorf("not a valid CqlResultType string")
}

func CqlResultTypePtr(v CqlResultType) *CqlResultType { return &v }

type Column struct {
	Name      []byte  `thrift:"name,1,required"`
	Value     *[]byte `thrift:"value,2"`
	Timestamp *int64  `thrift:"timestamp,3"`
	Ttl       *int32  `thrift:"ttl,4"`
}

func NewColumn() *Column {
	rval := &Column{}
	return rval
}

func (p *Column) IsSetValue() bool {
	return p.Value != nil
}

func (p *Column) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *Column) IsSetTtl() bool {
	return p.Ttl != nil
}

func (p *Column) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *Column) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *Column) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Value = &v
	}
	return nil
}

func (p *Column) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *Column) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Ttl = &v
	}
	return nil
}

func (p *Column) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Column"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *Column) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *Column) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Value != nil {
		if p.IsSetValue() {
			if err := oprot.WriteFieldBegin("value", thrift.STRING, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:value: %s", p, err)
			}
			if err := oprot.WriteBinary(*p.Value); err != nil {
				return fmt.Errorf("%T.value (2) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:value: %s", p, err)
			}
		}
	}
	return err
}

func (p *Column) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.Timestamp)); err != nil {
			return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
		}
	}
	return err
}

func (p *Column) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetTtl() {
		if err := oprot.WriteFieldBegin("ttl", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:ttl: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Ttl)); err != nil {
			return fmt.Errorf("%T.ttl (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:ttl: %s", p, err)
		}
	}
	return err
}

func (p *Column) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Column(%+v)", *p)
}

type SuperColumn struct {
	Name    []byte    `thrift:"name,1,required"`
	Columns []*Column `thrift:"columns,2,required"`
}

func NewSuperColumn() *SuperColumn {
	rval := &SuperColumn{}
	return rval
}

func (p *SuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SuperColumn) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *SuperColumn) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*Column, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem0 := NewColumn()
		if err := _elem0.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem0, err)
		}
		p.Columns = append(p.Columns, _elem0)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SuperColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *SuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *SuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SuperColumn(%+v)", *p)
}

type CounterColumn struct {
	Name  []byte `thrift:"name,1,required"`
	Value int64  `thrift:"value,2,required"`
}

func NewCounterColumn() *CounterColumn {
	rval := &CounterColumn{}
	return rval
}

func (p *CounterColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CounterColumn) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *CounterColumn) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CounterColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CounterColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CounterColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *CounterColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.I64, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:value: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Value)); err != nil {
		return fmt.Errorf("%T.value (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:value: %s", p, err)
	}
	return err
}

func (p *CounterColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CounterColumn(%+v)", *p)
}

type CounterSuperColumn struct {
	Name    []byte           `thrift:"name,1,required"`
	Columns []*CounterColumn `thrift:"columns,2,required"`
}

func NewCounterSuperColumn() *CounterSuperColumn {
	rval := &CounterSuperColumn{}
	return rval
}

func (p *CounterSuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CounterSuperColumn) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *CounterSuperColumn) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*CounterColumn, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem1 := NewCounterColumn()
		if err := _elem1.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem1, err)
		}
		p.Columns = append(p.Columns, _elem1)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CounterSuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CounterSuperColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CounterSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *CounterSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *CounterSuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CounterSuperColumn(%+v)", *p)
}

type ColumnOrSuperColumn struct {
	Column             *Column             `thrift:"column,1"`
	SuperColumn        *SuperColumn        `thrift:"super_column,2"`
	CounterColumn      *CounterColumn      `thrift:"counter_column,3"`
	CounterSuperColumn *CounterSuperColumn `thrift:"counter_super_column,4"`
}

func NewColumnOrSuperColumn() *ColumnOrSuperColumn {
	rval := &ColumnOrSuperColumn{}
	return rval
}

func (p *ColumnOrSuperColumn) IsSetColumn() bool {
	return p.Column != nil
}

func (p *ColumnOrSuperColumn) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnOrSuperColumn) IsSetCounterColumn() bool {
	return p.CounterColumn != nil
}

func (p *ColumnOrSuperColumn) IsSetCounterSuperColumn() bool {
	return p.CounterSuperColumn != nil
}

func (p *ColumnOrSuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField1(iprot thrift.TProtocol) error {
	p.Column = NewColumn()
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField2(iprot thrift.TProtocol) error {
	p.SuperColumn = NewSuperColumn()
	if err := p.SuperColumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SuperColumn, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField3(iprot thrift.TProtocol) error {
	p.CounterColumn = NewCounterColumn()
	if err := p.CounterColumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CounterColumn, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField4(iprot thrift.TProtocol) error {
	p.CounterSuperColumn = NewCounterSuperColumn()
	if err := p.CounterSuperColumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CounterSuperColumn, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnOrSuperColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if p.IsSetColumn() {
			if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:column: %s", p, err)
			}
			if err := p.Column.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Column, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRUCT, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:super_column: %s", p, err)
			}
			if err := p.SuperColumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.SuperColumn, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField3(oprot thrift.TProtocol) (err error) {
	if p.CounterColumn != nil {
		if p.IsSetCounterColumn() {
			if err := oprot.WriteFieldBegin("counter_column", thrift.STRUCT, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:counter_column: %s", p, err)
			}
			if err := p.CounterColumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.CounterColumn, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:counter_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField4(oprot thrift.TProtocol) (err error) {
	if p.CounterSuperColumn != nil {
		if p.IsSetCounterSuperColumn() {
			if err := oprot.WriteFieldBegin("counter_super_column", thrift.STRUCT, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:counter_super_column: %s", p, err)
			}
			if err := p.CounterSuperColumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.CounterSuperColumn, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:counter_super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnOrSuperColumn(%+v)", *p)
}

type NotFoundException struct {
}

func NewNotFoundException() *NotFoundException {
	rval := &NotFoundException{}
	return rval
}

func (p *NotFoundException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NotFoundException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("NotFoundException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *NotFoundException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NotFoundException(%+v)", *p)
}

func (p *NotFoundException) Error() string {
	return p.String()
}

type InvalidRequestException struct {
	Why string `thrift:"why,1,required"`
}

func NewInvalidRequestException() *InvalidRequestException {
	rval := &InvalidRequestException{}
	return rval
}

func (p *InvalidRequestException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InvalidRequestException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Why = v
	}
	return nil
}

func (p *InvalidRequestException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("InvalidRequestException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *InvalidRequestException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:why: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return fmt.Errorf("%T.why (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:why: %s", p, err)
	}
	return err
}

func (p *InvalidRequestException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InvalidRequestException(%+v)", *p)
}

func (p *InvalidRequestException) Error() string {
	return p.String()
}

type UnavailableException struct {
}

func NewUnavailableException() *UnavailableException {
	rval := &UnavailableException{}
	return rval
}

func (p *UnavailableException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UnavailableException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UnavailableException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UnavailableException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UnavailableException(%+v)", *p)
}

func (p *UnavailableException) Error() string {
	return p.String()
}

type TimedOutException struct {
}

func NewTimedOutException() *TimedOutException {
	rval := &TimedOutException{}
	return rval
}

func (p *TimedOutException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TimedOutException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TimedOutException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TimedOutException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TimedOutException(%+v)", *p)
}

func (p *TimedOutException) Error() string {
	return p.String()
}

type AuthenticationException struct {
	Why string `thrift:"why,1,required"`
}

func NewAuthenticationException() *AuthenticationException {
	rval := &AuthenticationException{}
	return rval
}

func (p *AuthenticationException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticationException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Why = v
	}
	return nil
}

func (p *AuthenticationException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthenticationException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticationException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:why: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return fmt.Errorf("%T.why (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:why: %s", p, err)
	}
	return err
}

func (p *AuthenticationException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticationException(%+v)", *p)
}

func (p *AuthenticationException) Error() string {
	return p.String()
}

type AuthorizationException struct {
	Why string `thrift:"why,1,required"`
}

func NewAuthorizationException() *AuthorizationException {
	rval := &AuthorizationException{}
	return rval
}

func (p *AuthorizationException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthorizationException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Why = v
	}
	return nil
}

func (p *AuthorizationException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthorizationException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthorizationException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:why: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return fmt.Errorf("%T.why (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:why: %s", p, err)
	}
	return err
}

func (p *AuthorizationException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthorizationException(%+v)", *p)
}

func (p *AuthorizationException) Error() string {
	return p.String()
}

type SchemaDisagreementException struct {
}

func NewSchemaDisagreementException() *SchemaDisagreementException {
	rval := &SchemaDisagreementException{}
	return rval
}

func (p *SchemaDisagreementException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SchemaDisagreementException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SchemaDisagreementException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SchemaDisagreementException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SchemaDisagreementException(%+v)", *p)
}

func (p *SchemaDisagreementException) Error() string {
	return p.String()
}

type ColumnParent struct {
	// unused field # 1
	// unused field # 2
	ColumnFamily string  `thrift:"column_family,3,required"`
	SuperColumn  *[]byte `thrift:"super_column,4"`
}

func NewColumnParent() *ColumnParent {
	rval := &ColumnParent{}
	return rval
}

func (p *ColumnParent) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnParent) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnParent) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *ColumnParent) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.SuperColumn = &v
	}
	return nil
}

func (p *ColumnParent) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnParent"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnParent) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column_family: %s", p, err)
	}
	return err
}

func (p *ColumnParent) writeField4(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:super_column: %s", p, err)
			}
			if err := oprot.WriteBinary(*p.SuperColumn); err != nil {
				return fmt.Errorf("%T.super_column (4) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnParent) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnParent(%+v)", *p)
}

type ColumnPath struct {
	// unused field # 1
	// unused field # 2
	ColumnFamily string  `thrift:"column_family,3,required"`
	SuperColumn  *[]byte `thrift:"super_column,4"`
	Column       *[]byte `thrift:"column,5"`
}

func NewColumnPath() *ColumnPath {
	rval := &ColumnPath{}
	return rval
}

func (p *ColumnPath) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnPath) IsSetColumn() bool {
	return p.Column != nil
}

func (p *ColumnPath) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnPath) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *ColumnPath) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.SuperColumn = &v
	}
	return nil
}

func (p *ColumnPath) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Column = &v
	}
	return nil
}

func (p *ColumnPath) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnPath"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnPath) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column_family: %s", p, err)
	}
	return err
}

func (p *ColumnPath) writeField4(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:super_column: %s", p, err)
			}
			if err := oprot.WriteBinary(*p.SuperColumn); err != nil {
				return fmt.Errorf("%T.super_column (4) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnPath) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if p.IsSetColumn() {
			if err := oprot.WriteFieldBegin("column", thrift.STRING, 5); err != nil {
				return fmt.Errorf("%T write field begin error 5:column: %s", p, err)
			}
			if err := oprot.WriteBinary(*p.Column); err != nil {
				return fmt.Errorf("%T.column (5) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 5:column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnPath) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnPath(%+v)", *p)
}

type SliceRange struct {
	Start    []byte `thrift:"start,1,required"`
	Finish   []byte `thrift:"finish,2,required"`
	Reversed bool   `thrift:"reversed,3,required"`
	Count    int32  `thrift:"count,4,required"`
}

func NewSliceRange() *SliceRange {
	rval := &SliceRange{
		Reversed: false,

		Count: 100,
	}
	return rval
}

func (p *SliceRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SliceRange) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Start = v
	}
	return nil
}

func (p *SliceRange) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Finish = v
	}
	return nil
}

func (p *SliceRange) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Reversed = v
	}
	return nil
}

func (p *SliceRange) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *SliceRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SliceRange"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SliceRange) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Start != nil {
		if err := oprot.WriteFieldBegin("start", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:start: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Start); err != nil {
			return fmt.Errorf("%T.start (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:start: %s", p, err)
		}
	}
	return err
}

func (p *SliceRange) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Finish != nil {
		if err := oprot.WriteFieldBegin("finish", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:finish: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Finish); err != nil {
			return fmt.Errorf("%T.finish (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:finish: %s", p, err)
		}
	}
	return err
}

func (p *SliceRange) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reversed", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:reversed: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Reversed)); err != nil {
		return fmt.Errorf("%T.reversed (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:reversed: %s", p, err)
	}
	return err
}

func (p *SliceRange) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:count: %s", p, err)
	}
	return err
}

func (p *SliceRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SliceRange(%+v)", *p)
}

type SlicePredicate struct {
	ColumnNames *[][]byte   `thrift:"column_names,1"`
	SliceRange  *SliceRange `thrift:"slice_range,2"`
}

func NewSlicePredicate() *SlicePredicate {
	rval := &SlicePredicate{}
	return rval
}

func (p *SlicePredicate) IsSetColumnNames() bool {
	return p.ColumnNames != nil
}

func (p *SlicePredicate) IsSetSliceRange() bool {
	return p.SliceRange != nil
}

func (p *SlicePredicate) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SlicePredicate) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([][]byte, 0, size)
	p.ColumnNames = &tSlice
	for i := 0; i < size; i++ {
		var _elem2 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem2 = v
		}
		(*p.ColumnNames) = append((*p.ColumnNames), _elem2)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SlicePredicate) readField2(iprot thrift.TProtocol) error {
	p.SliceRange = NewSliceRange()
	if err := p.SliceRange.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SliceRange, err)
	}
	return nil
}

func (p *SlicePredicate) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SlicePredicate"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SlicePredicate) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnNames != nil {
		if p.IsSetColumnNames() {
			if err := oprot.WriteFieldBegin("column_names", thrift.LIST, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:column_names: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(*p.ColumnNames)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range *p.ColumnNames {
				if err := oprot.WriteBinary(v); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:column_names: %s", p, err)
			}
		}
	}
	return err
}

func (p *SlicePredicate) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SliceRange != nil {
		if p.IsSetSliceRange() {
			if err := oprot.WriteFieldBegin("slice_range", thrift.STRUCT, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:slice_range: %s", p, err)
			}
			if err := p.SliceRange.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.SliceRange, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:slice_range: %s", p, err)
			}
		}
	}
	return err
}

func (p *SlicePredicate) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SlicePredicate(%+v)", *p)
}

type IndexExpression struct {
	ColumnName []byte        `thrift:"column_name,1,required"`
	Op         IndexOperator `thrift:"op,2,required"`
	Value      []byte        `thrift:"value,3,required"`
}

func NewIndexExpression() *IndexExpression {
	rval := &IndexExpression{}
	return rval
}

func (p *IndexExpression) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IndexExpression) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ColumnName = v
	}
	return nil
}

func (p *IndexExpression) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := IndexOperator(v)
		p.Op = temp
	}
	return nil
}

func (p *IndexExpression) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *IndexExpression) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IndexExpression"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IndexExpression) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnName != nil {
		if err := oprot.WriteFieldBegin("column_name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:column_name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.ColumnName); err != nil {
			return fmt.Errorf("%T.column_name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:column_name: %s", p, err)
		}
	}
	return err
}

func (p *IndexExpression) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("op", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:op: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Op)); err != nil {
		return fmt.Errorf("%T.op (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:op: %s", p, err)
	}
	return err
}

func (p *IndexExpression) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Value != nil {
		if err := oprot.WriteFieldBegin("value", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:value: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Value); err != nil {
			return fmt.Errorf("%T.value (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:value: %s", p, err)
		}
	}
	return err
}

func (p *IndexExpression) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IndexExpression(%+v)", *p)
}

type IndexClause struct {
	Expressions []*IndexExpression `thrift:"expressions,1,required"`
	StartKey    []byte             `thrift:"start_key,2,required"`
	Count       int32              `thrift:"count,3,required"`
}

func NewIndexClause() *IndexClause {
	rval := &IndexClause{
		Count: 100,
	}
	return rval
}

func (p *IndexClause) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IndexClause) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*IndexExpression, 0, size)
	p.Expressions = tSlice
	for i := 0; i < size; i++ {
		_elem3 := NewIndexExpression()
		if err := _elem3.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem3, err)
		}
		p.Expressions = append(p.Expressions, _elem3)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *IndexClause) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.StartKey = v
	}
	return nil
}

func (p *IndexClause) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *IndexClause) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IndexClause"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IndexClause) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Expressions != nil {
		if err := oprot.WriteFieldBegin("expressions", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:expressions: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Expressions)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Expressions {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:expressions: %s", p, err)
		}
	}
	return err
}

func (p *IndexClause) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartKey != nil {
		if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:start_key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartKey); err != nil {
			return fmt.Errorf("%T.start_key (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:start_key: %s", p, err)
		}
	}
	return err
}

func (p *IndexClause) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:count: %s", p, err)
	}
	return err
}

func (p *IndexClause) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IndexClause(%+v)", *p)
}

type KeyRange struct {
	StartKey   *[]byte `thrift:"start_key,1"`
	EndKey     *[]byte `thrift:"end_key,2"`
	StartToken *string `thrift:"start_token,3"`
	EndToken   *string `thrift:"end_token,4"`
	Count      int32   `thrift:"count,5,required"`
}

func NewKeyRange() *KeyRange {
	rval := &KeyRange{
		Count: 100,
	}
	return rval
}

func (p *KeyRange) IsSetStartKey() bool {
	return p.StartKey != nil
}

func (p *KeyRange) IsSetEndKey() bool {
	return p.EndKey != nil
}

func (p *KeyRange) IsSetStartToken() bool {
	return p.StartToken != nil
}

func (p *KeyRange) IsSetEndToken() bool {
	return p.EndToken != nil
}

func (p *KeyRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeyRange) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.StartKey = &v
	}
	return nil
}

func (p *KeyRange) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.EndKey = &v
	}
	return nil
}

func (p *KeyRange) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.StartToken = &v
	}
	return nil
}

func (p *KeyRange) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.EndToken = &v
	}
	return nil
}

func (p *KeyRange) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *KeyRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyRange"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KeyRange) writeField1(oprot thrift.TProtocol) (err error) {
	if p.StartKey != nil {
		if p.IsSetStartKey() {
			if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:start_key: %s", p, err)
			}
			if err := oprot.WriteBinary(*p.StartKey); err != nil {
				return fmt.Errorf("%T.start_key (1) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:start_key: %s", p, err)
			}
		}
	}
	return err
}

func (p *KeyRange) writeField2(oprot thrift.TProtocol) (err error) {
	if p.EndKey != nil {
		if p.IsSetEndKey() {
			if err := oprot.WriteFieldBegin("end_key", thrift.STRING, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:end_key: %s", p, err)
			}
			if err := oprot.WriteBinary(*p.EndKey); err != nil {
				return fmt.Errorf("%T.end_key (2) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:end_key: %s", p, err)
			}
		}
	}
	return err
}

func (p *KeyRange) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetStartToken() {
		if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:start_token: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.StartToken)); err != nil {
			return fmt.Errorf("%T.start_token (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:start_token: %s", p, err)
		}
	}
	return err
}

func (p *KeyRange) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetEndToken() {
		if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:end_token: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.EndToken)); err != nil {
			return fmt.Errorf("%T.end_token (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:end_token: %s", p, err)
		}
	}
	return err
}

func (p *KeyRange) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:count: %s", p, err)
	}
	return err
}

func (p *KeyRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyRange(%+v)", *p)
}

type KeySlice struct {
	Key     []byte                 `thrift:"key,1,required"`
	Columns []*ColumnOrSuperColumn `thrift:"columns,2,required"`
}

func NewKeySlice() *KeySlice {
	rval := &KeySlice{}
	return rval
}

func (p *KeySlice) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeySlice) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *KeySlice) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*ColumnOrSuperColumn, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem4 := NewColumnOrSuperColumn()
		if err := _elem4.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem4, err)
		}
		p.Columns = append(p.Columns, _elem4)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *KeySlice) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeySlice"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KeySlice) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *KeySlice) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *KeySlice) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeySlice(%+v)", *p)
}

type KeyCount struct {
	Key   []byte `thrift:"key,1,required"`
	Count int32  `thrift:"count,2,required"`
}

func NewKeyCount() *KeyCount {
	rval := &KeyCount{}
	return rval
}

func (p *KeyCount) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeyCount) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *KeyCount) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *KeyCount) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyCount"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KeyCount) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *KeyCount) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:count: %s", p, err)
	}
	return err
}

func (p *KeyCount) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyCount(%+v)", *p)
}

type Deletion struct {
	Timestamp   *int64          `thrift:"timestamp,1"`
	SuperColumn *[]byte         `thrift:"super_column,2"`
	Predicate   *SlicePredicate `thrift:"predicate,3"`
}

func NewDeletion() *Deletion {
	rval := &Deletion{}
	return rval
}

func (p *Deletion) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *Deletion) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *Deletion) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *Deletion) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *Deletion) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *Deletion) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.SuperColumn = &v
	}
	return nil
}

func (p *Deletion) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *Deletion) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Deletion"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *Deletion) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:timestamp: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.Timestamp)); err != nil {
			return fmt.Errorf("%T.timestamp (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:timestamp: %s", p, err)
		}
	}
	return err
}

func (p *Deletion) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:super_column: %s", p, err)
			}
			if err := oprot.WriteBinary(*p.SuperColumn); err != nil {
				return fmt.Errorf("%T.super_column (2) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *Deletion) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if p.IsSetPredicate() {
			if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
			}
			if err := p.Predicate.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
			}
		}
	}
	return err
}

func (p *Deletion) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Deletion(%+v)", *p)
}

type Mutation struct {
	ColumnOrSupercolumn *ColumnOrSuperColumn `thrift:"column_or_supercolumn,1"`
	Deletion            *Deletion            `thrift:"deletion,2"`
}

func NewMutation() *Mutation {
	rval := &Mutation{}
	return rval
}

func (p *Mutation) IsSetColumnOrSupercolumn() bool {
	return p.ColumnOrSupercolumn != nil
}

func (p *Mutation) IsSetDeletion() bool {
	return p.Deletion != nil
}

func (p *Mutation) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *Mutation) readField1(iprot thrift.TProtocol) error {
	p.ColumnOrSupercolumn = NewColumnOrSuperColumn()
	if err := p.ColumnOrSupercolumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnOrSupercolumn, err)
	}
	return nil
}

func (p *Mutation) readField2(iprot thrift.TProtocol) error {
	p.Deletion = NewDeletion()
	if err := p.Deletion.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Deletion, err)
	}
	return nil
}

func (p *Mutation) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Mutation"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *Mutation) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnOrSupercolumn != nil {
		if p.IsSetColumnOrSupercolumn() {
			if err := oprot.WriteFieldBegin("column_or_supercolumn", thrift.STRUCT, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:column_or_supercolumn: %s", p, err)
			}
			if err := p.ColumnOrSupercolumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.ColumnOrSupercolumn, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:column_or_supercolumn: %s", p, err)
			}
		}
	}
	return err
}

func (p *Mutation) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Deletion != nil {
		if p.IsSetDeletion() {
			if err := oprot.WriteFieldBegin("deletion", thrift.STRUCT, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:deletion: %s", p, err)
			}
			if err := p.Deletion.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Deletion, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:deletion: %s", p, err)
			}
		}
	}
	return err
}

func (p *Mutation) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Mutation(%+v)", *p)
}

type EndpointDetails struct {
	Host       string  `thrift:"host,1"`
	Datacenter string  `thrift:"datacenter,2"`
	Rack       *string `thrift:"rack,3"`
}

func NewEndpointDetails() *EndpointDetails {
	rval := &EndpointDetails{}
	return rval
}

func (p *EndpointDetails) IsSetRack() bool {
	return p.Rack != nil
}

func (p *EndpointDetails) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EndpointDetails) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Host = v
	}
	return nil
}

func (p *EndpointDetails) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Datacenter = v
	}
	return nil
}

func (p *EndpointDetails) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Rack = &v
	}
	return nil
}

func (p *EndpointDetails) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("EndpointDetails"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EndpointDetails) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("host", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:host: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Host)); err != nil {
		return fmt.Errorf("%T.host (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:host: %s", p, err)
	}
	return err
}

func (p *EndpointDetails) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("datacenter", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:datacenter: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Datacenter)); err != nil {
		return fmt.Errorf("%T.datacenter (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:datacenter: %s", p, err)
	}
	return err
}

func (p *EndpointDetails) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetRack() {
		if err := oprot.WriteFieldBegin("rack", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:rack: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Rack)); err != nil {
			return fmt.Errorf("%T.rack (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:rack: %s", p, err)
		}
	}
	return err
}

func (p *EndpointDetails) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EndpointDetails(%+v)", *p)
}

type TokenRange struct {
	StartToken      string              `thrift:"start_token,1,required"`
	EndToken        string              `thrift:"end_token,2,required"`
	Endpoints       []string            `thrift:"endpoints,3,required"`
	RpcEndpoints    *[]string           `thrift:"rpc_endpoints,4"`
	EndpointDetails *[]*EndpointDetails `thrift:"endpoint_details,5"`
}

func NewTokenRange() *TokenRange {
	rval := &TokenRange{}
	return rval
}

func (p *TokenRange) IsSetRpcEndpoints() bool {
	return p.RpcEndpoints != nil
}

func (p *TokenRange) IsSetEndpointDetails() bool {
	return p.EndpointDetails != nil
}

func (p *TokenRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TokenRange) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *TokenRange) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *TokenRange) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]string, 0, size)
	p.Endpoints = tSlice
	for i := 0; i < size; i++ {
		var _elem5 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem5 = v
		}
		p.Endpoints = append(p.Endpoints, _elem5)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *TokenRange) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]string, 0, size)
	p.RpcEndpoints = &tSlice
	for i := 0; i < size; i++ {
		var _elem6 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem6 = v
		}
		(*p.RpcEndpoints) = append((*p.RpcEndpoints), _elem6)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *TokenRange) readField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*EndpointDetails, 0, size)
	p.EndpointDetails = &tSlice
	for i := 0; i < size; i++ {
		_elem7 := NewEndpointDetails()
		if err := _elem7.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem7, err)
		}
		(*p.EndpointDetails) = append((*p.EndpointDetails), _elem7)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *TokenRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TokenRange"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TokenRange) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:start_token: %s", p, err)
	}
	return err
}

func (p *TokenRange) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:end_token: %s", p, err)
	}
	return err
}

func (p *TokenRange) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Endpoints != nil {
		if err := oprot.WriteFieldBegin("endpoints", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:endpoints: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Endpoints)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Endpoints {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:endpoints: %s", p, err)
		}
	}
	return err
}

func (p *TokenRange) writeField4(oprot thrift.TProtocol) (err error) {
	if p.RpcEndpoints != nil {
		if p.IsSetRpcEndpoints() {
			if err := oprot.WriteFieldBegin("rpc_endpoints", thrift.LIST, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:rpc_endpoints: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(*p.RpcEndpoints)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range *p.RpcEndpoints {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:rpc_endpoints: %s", p, err)
			}
		}
	}
	return err
}

func (p *TokenRange) writeField5(oprot thrift.TProtocol) (err error) {
	if p.EndpointDetails != nil {
		if p.IsSetEndpointDetails() {
			if err := oprot.WriteFieldBegin("endpoint_details", thrift.LIST, 5); err != nil {
				return fmt.Errorf("%T write field begin error 5:endpoint_details: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(*p.EndpointDetails)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range *p.EndpointDetails {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 5:endpoint_details: %s", p, err)
			}
		}
	}
	return err
}

func (p *TokenRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TokenRange(%+v)", *p)
}

type AuthenticationRequest struct {
	Credentials map[string]string `thrift:"credentials,1,required"`
}

func NewAuthenticationRequest() *AuthenticationRequest {
	rval := &AuthenticationRequest{}
	return rval
}

func (p *AuthenticationRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticationRequest) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string]string, size)
	p.Credentials = tMap
	for i := 0; i < size; i++ {
		var _key8 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key8 = v
		}
		var _val9 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val9 = v
		}
		p.Credentials[_key8] = _val9
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *AuthenticationRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthenticationRequest"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticationRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Credentials != nil {
		if err := oprot.WriteFieldBegin("credentials", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:credentials: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Credentials)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Credentials {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:credentials: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticationRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticationRequest(%+v)", *p)
}

type ColumnDef struct {
	Name            []byte             `thrift:"name,1,required"`
	ValidationClass string             `thrift:"validation_class,2,required"`
	IndexType       *IndexType         `thrift:"index_type,3"`
	IndexName       *string            `thrift:"index_name,4"`
	IndexOptions    *map[string]string `thrift:"index_options,5"`
}

func NewColumnDef() *ColumnDef {
	rval := &ColumnDef{}
	return rval
}

func (p *ColumnDef) IsSetIndexType() bool {
	return p.IndexType != nil
}

func (p *ColumnDef) IsSetIndexName() bool {
	return p.IndexName != nil
}

func (p *ColumnDef) IsSetIndexOptions() bool {
	return p.IndexOptions != nil
}

func (p *ColumnDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *ColumnDef) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.ValidationClass = v
	}
	return nil
}

func (p *ColumnDef) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := IndexType(v)
		p.IndexType = &temp
	}
	return nil
}

func (p *ColumnDef) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.IndexName = &v
	}
	return nil
}

func (p *ColumnDef) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string]string, size)
	p.IndexOptions = &tMap
	for i := 0; i < size; i++ {
		var _key10 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key10 = v
		}
		var _val11 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val11 = v
		}
		(*p.IndexOptions)[_key10] = _val11
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *ColumnDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnDef"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnDef) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *ColumnDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("validation_class", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:validation_class: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ValidationClass)); err != nil {
		return fmt.Errorf("%T.validation_class (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:validation_class: %s", p, err)
	}
	return err
}

func (p *ColumnDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexType() {
		if err := oprot.WriteFieldBegin("index_type", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:index_type: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.IndexType)); err != nil {
			return fmt.Errorf("%T.index_type (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:index_type: %s", p, err)
		}
	}
	return err
}

func (p *ColumnDef) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexName() {
		if err := oprot.WriteFieldBegin("index_name", thrift.STRING, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:index_name: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.IndexName)); err != nil {
			return fmt.Errorf("%T.index_name (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:index_name: %s", p, err)
		}
	}
	return err
}

func (p *ColumnDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IndexOptions != nil {
		if p.IsSetIndexOptions() {
			if err := oprot.WriteFieldBegin("index_options", thrift.MAP, 5); err != nil {
				return fmt.Errorf("%T write field begin error 5:index_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(*p.IndexOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range *p.IndexOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 5:index_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnDef(%+v)", *p)
}

type CfDef struct {
	Keyspace   string  `thrift:"keyspace,1,required"`
	Name       string  `thrift:"name,2,required"`
	ColumnType *string `thrift:"column_type,3"`
	// unused field # 4
	ComparatorType    *string `thrift:"comparator_type,5"`
	SubcomparatorType *string `thrift:"subcomparator_type,6"`
	// unused field # 7
	Comment *string `thrift:"comment,8"`
	// unused field # 9
	// unused field # 10
	// unused field # 11
	ReadRepairChance       *float64      `thrift:"read_repair_chance,12"`
	ColumnMetadata         *[]*ColumnDef `thrift:"column_metadata,13"`
	GcGraceSeconds         *int32        `thrift:"gc_grace_seconds,14"`
	DefaultValidationClass *string       `thrift:"default_validation_class,15"`
	Id                     *int32        `thrift:"id,16"`
	MinCompactionThreshold *int32        `thrift:"min_compaction_threshold,17"`
	MaxCompactionThreshold *int32        `thrift:"max_compaction_threshold,18"`
	// unused field # 19
	// unused field # 20
	// unused field # 21
	// unused field # 22
	// unused field # 23
	ReplicateOnWrite   *bool    `thrift:"replicate_on_write,24"`
	MergeShardsChance  *float64 `thrift:"merge_shards_chance,25"`
	KeyValidationClass *string  `thrift:"key_validation_class,26"`
	// unused field # 27
	KeyAlias                  *[]byte            `thrift:"key_alias,28"`
	CompactionStrategy        *string            `thrift:"compaction_strategy,29"`
	CompactionStrategyOptions *map[string]string `thrift:"compaction_strategy_options,30"`
	// unused field # 31
	CompressionOptions  *map[string]string `thrift:"compression_options,32"`
	BloomFilterFpChance *float64           `thrift:"bloom_filter_fp_chance,33"`
}

func NewCfDef() *CfDef {
	rval := &CfDef{
		ColumnType: new(string),

		ComparatorType: new(string),

		ReadRepairChance: new(float64),
	}
	*(rval.ColumnType) = "Standard"
	*(rval.ComparatorType) = "BytesType"
	*(rval.ReadRepairChance) = 1
	return rval
}

func (p *CfDef) IsSetColumnType() bool {
	return p.ColumnType != nil
}

func (p *CfDef) IsSetComparatorType() bool {
	return p.ComparatorType != nil
}

func (p *CfDef) IsSetSubcomparatorType() bool {
	return p.SubcomparatorType != nil
}

func (p *CfDef) IsSetComment() bool {
	return p.Comment != nil
}

func (p *CfDef) IsSetReadRepairChance() bool {
	return p.ReadRepairChance != nil
}

func (p *CfDef) IsSetColumnMetadata() bool {
	return p.ColumnMetadata != nil
}

func (p *CfDef) IsSetGcGraceSeconds() bool {
	return p.GcGraceSeconds != nil
}

func (p *CfDef) IsSetDefaultValidationClass() bool {
	return p.DefaultValidationClass != nil
}

func (p *CfDef) IsSetId() bool {
	return p.Id != nil
}

func (p *CfDef) IsSetMinCompactionThreshold() bool {
	return p.MinCompactionThreshold != nil
}

func (p *CfDef) IsSetMaxCompactionThreshold() bool {
	return p.MaxCompactionThreshold != nil
}

func (p *CfDef) IsSetReplicateOnWrite() bool {
	return p.ReplicateOnWrite != nil
}

func (p *CfDef) IsSetMergeShardsChance() bool {
	return p.MergeShardsChance != nil
}

func (p *CfDef) IsSetKeyValidationClass() bool {
	return p.KeyValidationClass != nil
}

func (p *CfDef) IsSetKeyAlias() bool {
	return p.KeyAlias != nil
}

func (p *CfDef) IsSetCompactionStrategy() bool {
	return p.CompactionStrategy != nil
}

func (p *CfDef) IsSetCompactionStrategyOptions() bool {
	return p.CompactionStrategyOptions != nil
}

func (p *CfDef) IsSetCompressionOptions() bool {
	return p.CompressionOptions != nil
}

func (p *CfDef) IsSetBloomFilterFpChance() bool {
	return p.BloomFilterFpChance != nil
}

func (p *CfDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 8:
			if err := p.readField8(iprot); err != nil {
				return err
			}
		case 12:
			if err := p.readField12(iprot); err != nil {
				return err
			}
		case 13:
			if err := p.readField13(iprot); err != nil {
				return err
			}
		case 14:
			if err := p.readField14(iprot); err != nil {
				return err
			}
		case 15:
			if err := p.readField15(iprot); err != nil {
				return err
			}
		case 16:
			if err := p.readField16(iprot); err != nil {
				return err
			}
		case 17:
			if err := p.readField17(iprot); err != nil {
				return err
			}
		case 18:
			if err := p.readField18(iprot); err != nil {
				return err
			}
		case 24:
			if err := p.readField24(iprot); err != nil {
				return err
			}
		case 25:
			if err := p.readField25(iprot); err != nil {
				return err
			}
		case 26:
			if err := p.readField26(iprot); err != nil {
				return err
			}
		case 28:
			if err := p.readField28(iprot); err != nil {
				return err
			}
		case 29:
			if err := p.readField29(iprot); err != nil {
				return err
			}
		case 30:
			if err := p.readField30(iprot); err != nil {
				return err
			}
		case 32:
			if err := p.readField32(iprot); err != nil {
				return err
			}
		case 33:
			if err := p.readField33(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CfDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *CfDef) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *CfDef) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.ColumnType = &v
	}
	return nil
}

func (p *CfDef) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.ComparatorType = &v
	}
	return nil
}

func (p *CfDef) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		p.SubcomparatorType = &v
	}
	return nil
}

func (p *CfDef) readField8(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 8: %s", err)
	} else {
		p.Comment = &v
	}
	return nil
}

func (p *CfDef) readField12(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 12: %s", err)
	} else {
		p.ReadRepairChance = &v
	}
	return nil
}

func (p *CfDef) readField13(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*ColumnDef, 0, size)
	p.ColumnMetadata = &tSlice
	for i := 0; i < size; i++ {
		_elem12 := NewColumnDef()
		if err := _elem12.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem12, err)
		}
		(*p.ColumnMetadata) = append((*p.ColumnMetadata), _elem12)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CfDef) readField14(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 14: %s", err)
	} else {
		p.GcGraceSeconds = &v
	}
	return nil
}

func (p *CfDef) readField15(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 15: %s", err)
	} else {
		p.DefaultValidationClass = &v
	}
	return nil
}

func (p *CfDef) readField16(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 16: %s", err)
	} else {
		p.Id = &v
	}
	return nil
}

func (p *CfDef) readField17(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 17: %s", err)
	} else {
		p.MinCompactionThreshold = &v
	}
	return nil
}

func (p *CfDef) readField18(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 18: %s", err)
	} else {
		p.MaxCompactionThreshold = &v
	}
	return nil
}

func (p *CfDef) readField24(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 24: %s", err)
	} else {
		p.ReplicateOnWrite = &v
	}
	return nil
}

func (p *CfDef) readField25(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 25: %s", err)
	} else {
		p.MergeShardsChance = &v
	}
	return nil
}

func (p *CfDef) readField26(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 26: %s", err)
	} else {
		p.KeyValidationClass = &v
	}
	return nil
}

func (p *CfDef) readField28(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 28: %s", err)
	} else {
		p.KeyAlias = &v
	}
	return nil
}

func (p *CfDef) readField29(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 29: %s", err)
	} else {
		p.CompactionStrategy = &v
	}
	return nil
}

func (p *CfDef) readField30(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string]string, size)
	p.CompactionStrategyOptions = &tMap
	for i := 0; i < size; i++ {
		var _key13 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key13 = v
		}
		var _val14 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val14 = v
		}
		(*p.CompactionStrategyOptions)[_key13] = _val14
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *CfDef) readField32(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string]string, size)
	p.CompressionOptions = &tMap
	for i := 0; i < size; i++ {
		var _key15 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key15 = v
		}
		var _val16 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val16 = v
		}
		(*p.CompressionOptions)[_key15] = _val16
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *CfDef) readField33(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 33: %s", err)
	} else {
		p.BloomFilterFpChance = &v
	}
	return nil
}

func (p *CfDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CfDef"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField8(oprot); err != nil {
		return err
	}
	if err := p.writeField12(oprot); err != nil {
		return err
	}
	if err := p.writeField13(oprot); err != nil {
		return err
	}
	if err := p.writeField14(oprot); err != nil {
		return err
	}
	if err := p.writeField15(oprot); err != nil {
		return err
	}
	if err := p.writeField16(oprot); err != nil {
		return err
	}
	if err := p.writeField17(oprot); err != nil {
		return err
	}
	if err := p.writeField18(oprot); err != nil {
		return err
	}
	if err := p.writeField24(oprot); err != nil {
		return err
	}
	if err := p.writeField25(oprot); err != nil {
		return err
	}
	if err := p.writeField26(oprot); err != nil {
		return err
	}
	if err := p.writeField28(oprot); err != nil {
		return err
	}
	if err := p.writeField29(oprot); err != nil {
		return err
	}
	if err := p.writeField30(oprot); err != nil {
		return err
	}
	if err := p.writeField32(oprot); err != nil {
		return err
	}
	if err := p.writeField33(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CfDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *CfDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *CfDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumnType() {
		if err := oprot.WriteFieldBegin("column_type", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column_type: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.ColumnType)); err != nil {
			return fmt.Errorf("%T.column_type (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column_type: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetComparatorType() {
		if err := oprot.WriteFieldBegin("comparator_type", thrift.STRING, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:comparator_type: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.ComparatorType)); err != nil {
			return fmt.Errorf("%T.comparator_type (5) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:comparator_type: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetSubcomparatorType() {
		if err := oprot.WriteFieldBegin("subcomparator_type", thrift.STRING, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:subcomparator_type: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.SubcomparatorType)); err != nil {
			return fmt.Errorf("%T.subcomparator_type (6) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:subcomparator_type: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField8(oprot thrift.TProtocol) (err error) {
	if p.IsSetComment() {
		if err := oprot.WriteFieldBegin("comment", thrift.STRING, 8); err != nil {
			return fmt.Errorf("%T write field begin error 8:comment: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Comment)); err != nil {
			return fmt.Errorf("%T.comment (8) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 8:comment: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField12(oprot thrift.TProtocol) (err error) {
	if p.IsSetReadRepairChance() {
		if err := oprot.WriteFieldBegin("read_repair_chance", thrift.DOUBLE, 12); err != nil {
			return fmt.Errorf("%T write field begin error 12:read_repair_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.ReadRepairChance)); err != nil {
			return fmt.Errorf("%T.read_repair_chance (12) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 12:read_repair_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField13(oprot thrift.TProtocol) (err error) {
	if p.ColumnMetadata != nil {
		if p.IsSetColumnMetadata() {
			if err := oprot.WriteFieldBegin("column_metadata", thrift.LIST, 13); err != nil {
				return fmt.Errorf("%T write field begin error 13:column_metadata: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(*p.ColumnMetadata)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range *p.ColumnMetadata {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 13:column_metadata: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField14(oprot thrift.TProtocol) (err error) {
	if p.IsSetGcGraceSeconds() {
		if err := oprot.WriteFieldBegin("gc_grace_seconds", thrift.I32, 14); err != nil {
			return fmt.Errorf("%T write field begin error 14:gc_grace_seconds: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.GcGraceSeconds)); err != nil {
			return fmt.Errorf("%T.gc_grace_seconds (14) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 14:gc_grace_seconds: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField15(oprot thrift.TProtocol) (err error) {
	if p.IsSetDefaultValidationClass() {
		if err := oprot.WriteFieldBegin("default_validation_class", thrift.STRING, 15); err != nil {
			return fmt.Errorf("%T write field begin error 15:default_validation_class: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.DefaultValidationClass)); err != nil {
			return fmt.Errorf("%T.default_validation_class (15) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 15:default_validation_class: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField16(oprot thrift.TProtocol) (err error) {
	if p.IsSetId() {
		if err := oprot.WriteFieldBegin("id", thrift.I32, 16); err != nil {
			return fmt.Errorf("%T write field begin error 16:id: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Id)); err != nil {
			return fmt.Errorf("%T.id (16) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 16:id: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField17(oprot thrift.TProtocol) (err error) {
	if p.IsSetMinCompactionThreshold() {
		if err := oprot.WriteFieldBegin("min_compaction_threshold", thrift.I32, 17); err != nil {
			return fmt.Errorf("%T write field begin error 17:min_compaction_threshold: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.MinCompactionThreshold)); err != nil {
			return fmt.Errorf("%T.min_compaction_threshold (17) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 17:min_compaction_threshold: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField18(oprot thrift.TProtocol) (err error) {
	if p.IsSetMaxCompactionThreshold() {
		if err := oprot.WriteFieldBegin("max_compaction_threshold", thrift.I32, 18); err != nil {
			return fmt.Errorf("%T write field begin error 18:max_compaction_threshold: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.MaxCompactionThreshold)); err != nil {
			return fmt.Errorf("%T.max_compaction_threshold (18) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 18:max_compaction_threshold: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField24(oprot thrift.TProtocol) (err error) {
	if p.IsSetReplicateOnWrite() {
		if err := oprot.WriteFieldBegin("replicate_on_write", thrift.BOOL, 24); err != nil {
			return fmt.Errorf("%T write field begin error 24:replicate_on_write: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.ReplicateOnWrite)); err != nil {
			return fmt.Errorf("%T.replicate_on_write (24) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 24:replicate_on_write: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField25(oprot thrift.TProtocol) (err error) {
	if p.IsSetMergeShardsChance() {
		if err := oprot.WriteFieldBegin("merge_shards_chance", thrift.DOUBLE, 25); err != nil {
			return fmt.Errorf("%T write field begin error 25:merge_shards_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.MergeShardsChance)); err != nil {
			return fmt.Errorf("%T.merge_shards_chance (25) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 25:merge_shards_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField26(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyValidationClass() {
		if err := oprot.WriteFieldBegin("key_validation_class", thrift.STRING, 26); err != nil {
			return fmt.Errorf("%T write field begin error 26:key_validation_class: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.KeyValidationClass)); err != nil {
			return fmt.Errorf("%T.key_validation_class (26) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 26:key_validation_class: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField28(oprot thrift.TProtocol) (err error) {
	if p.KeyAlias != nil {
		if p.IsSetKeyAlias() {
			if err := oprot.WriteFieldBegin("key_alias", thrift.STRING, 28); err != nil {
				return fmt.Errorf("%T write field begin error 28:key_alias: %s", p, err)
			}
			if err := oprot.WriteBinary(*p.KeyAlias); err != nil {
				return fmt.Errorf("%T.key_alias (28) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 28:key_alias: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField29(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompactionStrategy() {
		if err := oprot.WriteFieldBegin("compaction_strategy", thrift.STRING, 29); err != nil {
			return fmt.Errorf("%T write field begin error 29:compaction_strategy: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.CompactionStrategy)); err != nil {
			return fmt.Errorf("%T.compaction_strategy (29) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 29:compaction_strategy: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField30(oprot thrift.TProtocol) (err error) {
	if p.CompactionStrategyOptions != nil {
		if p.IsSetCompactionStrategyOptions() {
			if err := oprot.WriteFieldBegin("compaction_strategy_options", thrift.MAP, 30); err != nil {
				return fmt.Errorf("%T write field begin error 30:compaction_strategy_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(*p.CompactionStrategyOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range *p.CompactionStrategyOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 30:compaction_strategy_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField32(oprot thrift.TProtocol) (err error) {
	if p.CompressionOptions != nil {
		if p.IsSetCompressionOptions() {
			if err := oprot.WriteFieldBegin("compression_options", thrift.MAP, 32); err != nil {
				return fmt.Errorf("%T write field begin error 32:compression_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(*p.CompressionOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range *p.CompressionOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 32:compression_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField33(oprot thrift.TProtocol) (err error) {
	if p.IsSetBloomFilterFpChance() {
		if err := oprot.WriteFieldBegin("bloom_filter_fp_chance", thrift.DOUBLE, 33); err != nil {
			return fmt.Errorf("%T write field begin error 33:bloom_filter_fp_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.BloomFilterFpChance)); err != nil {
			return fmt.Errorf("%T.bloom_filter_fp_chance (33) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 33:bloom_filter_fp_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CfDef(%+v)", *p)
}

type KsDef struct {
	Name              string             `thrift:"name,1,required"`
	StrategyClass     string             `thrift:"strategy_class,2,required"`
	StrategyOptions   *map[string]string `thrift:"strategy_options,3"`
	ReplicationFactor *int32             `thrift:"replication_factor,4"`
	CfDefs            []*CfDef           `thrift:"cf_defs,5,required"`
	DurableWrites     *bool              `thrift:"durable_writes,6"`
}

func NewKsDef() *KsDef {
	rval := &KsDef{
		DurableWrites: new(bool),
	}
	*(rval.DurableWrites) = true
	return rval
}

func (p *KsDef) IsSetStrategyOptions() bool {
	return p.StrategyOptions != nil
}

func (p *KsDef) IsSetReplicationFactor() bool {
	return p.ReplicationFactor != nil
}

func (p *KsDef) IsSetDurableWrites() bool {
	return p.DurableWrites != nil
}

func (p *KsDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KsDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *KsDef) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.StrategyClass = v
	}
	return nil
}

func (p *KsDef) readField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string]string, size)
	p.StrategyOptions = &tMap
	for i := 0; i < size; i++ {
		var _key17 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key17 = v
		}
		var _val18 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val18 = v
		}
		(*p.StrategyOptions)[_key17] = _val18
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *KsDef) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.ReplicationFactor = &v
	}
	return nil
}

func (p *KsDef) readField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*CfDef, 0, size)
	p.CfDefs = tSlice
	for i := 0; i < size; i++ {
		_elem19 := NewCfDef()
		if err := _elem19.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem19, err)
		}
		p.CfDefs = append(p.CfDefs, _elem19)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *KsDef) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		p.DurableWrites = &v
	}
	return nil
}

func (p *KsDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KsDef"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KsDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *KsDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("strategy_class", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:strategy_class: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StrategyClass)); err != nil {
		return fmt.Errorf("%T.strategy_class (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:strategy_class: %s", p, err)
	}
	return err
}

func (p *KsDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.StrategyOptions != nil {
		if p.IsSetStrategyOptions() {
			if err := oprot.WriteFieldBegin("strategy_options", thrift.MAP, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:strategy_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(*p.StrategyOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range *p.StrategyOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:strategy_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *KsDef) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetReplicationFactor() {
		if err := oprot.WriteFieldBegin("replication_factor", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:replication_factor: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.ReplicationFactor)); err != nil {
			return fmt.Errorf("%T.replication_factor (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:replication_factor: %s", p, err)
		}
	}
	return err
}

func (p *KsDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.CfDefs != nil {
		if err := oprot.WriteFieldBegin("cf_defs", thrift.LIST, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:cf_defs: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.CfDefs)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.CfDefs {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:cf_defs: %s", p, err)
		}
	}
	return err
}

func (p *KsDef) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetDurableWrites() {
		if err := oprot.WriteFieldBegin("durable_writes", thrift.BOOL, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:durable_writes: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.DurableWrites)); err != nil {
			return fmt.Errorf("%T.durable_writes (6) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:durable_writes: %s", p, err)
		}
	}
	return err
}

func (p *KsDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KsDef(%+v)", *p)
}

type CqlRow struct {
	Key     []byte    `thrift:"key,1,required"`
	Columns []*Column `thrift:"columns,2,required"`
}

func NewCqlRow() *CqlRow {
	rval := &CqlRow{}
	return rval
}

func (p *CqlRow) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlRow) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CqlRow) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*Column, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem20 := NewColumn()
		if err := _elem20.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem20, err)
		}
		p.Columns = append(p.Columns, _elem20)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CqlRow) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlRow"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlRow) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *CqlRow) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *CqlRow) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlRow(%+v)", *p)
}

type CqlMetadata struct {
	NameTypes        map[string]string `thrift:"name_types,1,required"`
	ValueTypes       map[string]string `thrift:"value_types,2,required"`
	DefaultNameType  string            `thrift:"default_name_type,3,required"`
	DefaultValueType string            `thrift:"default_value_type,4,required"`
}

func NewCqlMetadata() *CqlMetadata {
	rval := &CqlMetadata{}
	return rval
}

func (p *CqlMetadata) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlMetadata) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string]string, size)
	p.NameTypes = tMap
	for i := 0; i < size; i++ {
		var _key21 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key21 = v
		}
		var _val22 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val22 = v
		}
		p.NameTypes[_key21] = _val22
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *CqlMetadata) readField2(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string]string, size)
	p.ValueTypes = tMap
	for i := 0; i < size; i++ {
		var _key23 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key23 = v
		}
		var _val24 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val24 = v
		}
		p.ValueTypes[_key23] = _val24
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *CqlMetadata) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.DefaultNameType = v
	}
	return nil
}

func (p *CqlMetadata) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.DefaultValueType = v
	}
	return nil
}

func (p *CqlMetadata) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlMetadata"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlMetadata) writeField1(oprot thrift.TProtocol) (err error) {
	if p.NameTypes != nil {
		if err := oprot.WriteFieldBegin("name_types", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name_types: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.NameTypes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.NameTypes {
			if err := oprot.WriteBinary([]byte(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name_types: %s", p, err)
		}
	}
	return err
}

func (p *CqlMetadata) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ValueTypes != nil {
		if err := oprot.WriteFieldBegin("value_types", thrift.MAP, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:value_types: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.ValueTypes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.ValueTypes {
			if err := oprot.WriteBinary([]byte(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:value_types: %s", p, err)
		}
	}
	return err
}

func (p *CqlMetadata) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("default_name_type", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:default_name_type: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DefaultNameType)); err != nil {
		return fmt.Errorf("%T.default_name_type (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:default_name_type: %s", p, err)
	}
	return err
}

func (p *CqlMetadata) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("default_value_type", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:default_value_type: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DefaultValueType)); err != nil {
		return fmt.Errorf("%T.default_value_type (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:default_value_type: %s", p, err)
	}
	return err
}

func (p *CqlMetadata) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlMetadata(%+v)", *p)
}

type CqlResult struct {
	TypeA1 CqlResultType `thrift:"type,1,required"`
	Rows   *[]*CqlRow    `thrift:"rows,2"`
	Num    *int32        `thrift:"num,3"`
	Schema *CqlMetadata  `thrift:"schema,4"`
}

func NewCqlResult() *CqlResult {
	rval := &CqlResult{}
	return rval
}

func (p *CqlResult) IsSetRows() bool {
	return p.Rows != nil
}

func (p *CqlResult) IsSetNum() bool {
	return p.Num != nil
}

func (p *CqlResult) IsSetSchema() bool {
	return p.Schema != nil
}

func (p *CqlResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlResult) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := CqlResultType(v)
		p.TypeA1 = temp
	}
	return nil
}

func (p *CqlResult) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*CqlRow, 0, size)
	p.Rows = &tSlice
	for i := 0; i < size; i++ {
		_elem25 := NewCqlRow()
		if err := _elem25.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem25, err)
		}
		(*p.Rows) = append((*p.Rows), _elem25)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CqlResult) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Num = &v
	}
	return nil
}

func (p *CqlResult) readField4(iprot thrift.TProtocol) error {
	p.Schema = NewCqlMetadata()
	if err := p.Schema.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Schema, err)
	}
	return nil
}

func (p *CqlResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlResult"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlResult) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("type", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:type: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.TypeA1)); err != nil {
		return fmt.Errorf("%T.type (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:type: %s", p, err)
	}
	return err
}

func (p *CqlResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if p.IsSetRows() {
			if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(*p.Rows)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range *p.Rows {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetNum() {
		if err := oprot.WriteFieldBegin("num", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:num: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Num)); err != nil {
			return fmt.Errorf("%T.num (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:num: %s", p, err)
		}
	}
	return err
}

func (p *CqlResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Schema != nil {
		if p.IsSetSchema() {
			if err := oprot.WriteFieldBegin("schema", thrift.STRUCT, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:schema: %s", p, err)
			}
			if err := p.Schema.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Schema, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:schema: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlResult(%+v)", *p)
}

type CqlPreparedResult struct {
	ItemId int32 `thrift:"itemId,1,required"`
	Count  int32 `thrift:"count,2,required"`
}

func NewCqlPreparedResult() *CqlPreparedResult {
	rval := &CqlPreparedResult{}
	return rval
}

func (p *CqlPreparedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlPreparedResult) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *CqlPreparedResult) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *CqlPreparedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlPreparedResult"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlPreparedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:itemId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return fmt.Errorf("%T.itemId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:itemId: %s", p, err)
	}
	return err
}

func (p *CqlPreparedResult) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:count: %s", p, err)
	}
	return err
}

func (p *CqlPreparedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlPreparedResult(%+v)", *p)
}
