// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cassandra

import (
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf

type Cassandra interface {
	// Parameters:
	//  - AuthRequest
	Login(auth_request *AuthenticationRequest) (err error)
	// Parameters:
	//  - Keyspace
	SetKeyspace(keyspace string) (err error)
	// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
	// the only method that can throw an exception under non-failure conditions.)
	//
	// Parameters:
	//  - Key
	//  - ColumnPath
	//  - ConsistencyLevel
	Get(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, err error)
	// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
	// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	GetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, err error)
	// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
	// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	GetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, err error)
	// Performs a get_slice for column_parent and predicate for the given keys in parallel.
	//
	// Parameters:
	//  - Keys
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	MultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, err error)
	// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
	//
	// Parameters:
	//  - Keys
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	MultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, err error)
	// returns a subset of columns for a contiguous range of keys.
	//
	// Parameters:
	//  - ColumnParent
	//  - Predicate
	//  - RangeA1
	//  - ConsistencyLevel
	GetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
	// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
	//
	// Parameters:
	//  - ColumnParent
	//  - IndexClause
	//  - ColumnPredicate
	//  - ConsistencyLevel
	GetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
	// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Column
	//  - ConsistencyLevel
	Insert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error)
	// Increment or decrement a counter.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Column
	//  - ConsistencyLevel
	Add(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error)
	// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
	// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
	// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
	//
	// Parameters:
	//  - Key
	//  - ColumnPath
	//  - Timestamp
	//  - ConsistencyLevel
	Remove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error)
	// Remove a counter at the specified location.
	// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
	// until the delete has reached all the nodes and all of them have been fully compacted.
	//
	// Parameters:
	//  - Key
	//  - Path
	//  - ConsistencyLevel
	RemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error)
	//   Mutate many columns or super columns for many row keys. See also: Mutation.
	//
	//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
	// *
	//
	// Parameters:
	//  - MutationMap
	//  - ConsistencyLevel
	BatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error)
	// Truncate will mark and entire column family as deleted.
	// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
	// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
	// only marks the data as deleted.
	// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
	// some hosts are down.
	//
	// Parameters:
	//  - Cfname
	Truncate(cfname string) (err error)
	// for each schema version present in the cluster, returns a list of nodes at that version.
	// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
	// the cluster is all on the same version if the size of the map is 1.
	DescribeSchemaVersions() (r map[string][]string, err error)
	// list the defined keyspaces in this cluster
	DescribeKeyspaces() (r []*KsDef, err error)
	// get the cluster name
	DescribeClusterName() (r string, err error)
	// get the thrift api version
	DescribeVersion() (r string, err error)
	// get the token ring: a map of ranges to host addresses,
	// represented as a set of TokenRange instead of a map from range
	// to list of endpoints, because you can't use Thrift structs as
	// map keys:
	// https://issues.apache.org/jira/browse/THRIFT-162
	//
	// for the same reason, we can't return a set here, even though
	// order is neither important nor predictable.
	//
	// Parameters:
	//  - Keyspace
	DescribeRing(keyspace string) (r []*TokenRange, err error)
	// returns the partitioner used by this cluster
	DescribePartitioner() (r string, err error)
	// returns the snitch used by this cluster
	DescribeSnitch() (r string, err error)
	// describe specified keyspace
	//
	// Parameters:
	//  - Keyspace
	DescribeKeyspace(keyspace string) (r *KsDef, err error)
	// experimental API for hadoop/parallel query support.
	// may change violently and without warning.
	//
	// returns list of token strings such that first subrange is (list[0], list[1]],
	// next is (list[1], list[2]], etc.
	//
	// Parameters:
	//  - CfName
	//  - StartToken
	//  - EndToken
	//  - KeysPerSplit
	DescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (r []string, err error)
	// adds a column family. returns the new schema id.
	//
	// Parameters:
	//  - CfDef
	SystemAddColumnFamily(cf_def *CfDef) (r string, err error)
	// drops a column family. returns the new schema id.
	//
	// Parameters:
	//  - ColumnFamily
	SystemDropColumnFamily(column_family string) (r string, err error)
	// adds a keyspace and any column families that are part of it. returns the new schema id.
	//
	// Parameters:
	//  - KsDef
	SystemAddKeyspace(ks_def *KsDef) (r string, err error)
	// drops a keyspace and any column families that are part of it. returns the new schema id.
	//
	// Parameters:
	//  - Keyspace
	SystemDropKeyspace(keyspace string) (r string, err error)
	// updates properties of a keyspace. returns the new schema id.
	//
	// Parameters:
	//  - KsDef
	SystemUpdateKeyspace(ks_def *KsDef) (r string, err error)
	// updates properties of a column family. returns the new schema id.
	//
	// Parameters:
	//  - CfDef
	SystemUpdateColumnFamily(cf_def *CfDef) (r string, err error)
	// Executes a CQL (Cassandra Query Language) statement and returns a
	// CqlResult containing the results.
	//
	// Parameters:
	//  - Query
	//  - Compression
	ExecuteCqlQuery(query []byte, compression Compression) (r *CqlResult, err error)
	// Prepare a CQL (Cassandra Query Language) statement by compiling and returning
	// - the type of CQL statement
	// - an id token of the compiled CQL stored on the server side.
	// - a count of the discovered bound markers in the statement
	//
	// Parameters:
	//  - Query
	//  - Compression
	PrepareCqlQuery(query []byte, compression Compression) (r *CqlPreparedResult, err error)
	// Executes a prepared CQL (Cassandra Query Language) statement by passing an id token and  a list of variables
	// to bind and returns a CqlResult containing the results.
	//
	// Parameters:
	//  - ItemId
	//  - Values
	ExecutePreparedCqlQuery(itemId int32, values []string) (r *CqlResult, err error)
}

type CassandraClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewCassandraClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *CassandraClient {
	return &CassandraClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewCassandraClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *CassandraClient {
	return &CassandraClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - AuthRequest
func (p *CassandraClient) Login(auth_request *AuthenticationRequest) (err error) {
	if err = p.sendLogin(auth_request); err != nil {
		return
	}
	return p.recvLogin()
}

func (p *CassandraClient) sendLogin(auth_request *AuthenticationRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("login", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args26 := NewLoginArgs()
	args26.AuthRequest = auth_request
	if err = args26.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvLogin() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error28 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error29 error
		error29, err = error28.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error29
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "login failed: out of sequence response")
		return
	}
	result27 := NewLoginResult()
	if err = result27.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result27.Authnx != nil {
		err = result27.Authnx
		return
	} else if result27.Authzx != nil {
		err = result27.Authzx
		return
	}
	return
}

// Parameters:
//  - Keyspace
func (p *CassandraClient) SetKeyspace(keyspace string) (err error) {
	if err = p.sendSetKeyspace(keyspace); err != nil {
		return
	}
	return p.recvSetKeyspace()
}

func (p *CassandraClient) sendSetKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("set_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args30 := NewSetKeyspaceArgs()
	args30.Keyspace = keyspace
	if err = args30.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSetKeyspace() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "set_keyspace failed: out of sequence response")
		return
	}
	result31 := NewSetKeyspaceResult()
	if err = result31.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result31.Ire != nil {
		err = result31.Ire
		return
	}
	return
}

// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
// the only method that can throw an exception under non-failure conditions.)
//
// Parameters:
//  - Key
//  - ColumnPath
//  - ConsistencyLevel
func (p *CassandraClient) Get(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, err error) {
	if err = p.sendGet(key, column_path, consistency_level); err != nil {
		return
	}
	return p.recvGet()
}

func (p *CassandraClient) sendGet(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args34 := NewGetArgs()
	args34.Key = key
	args34.ColumnPath = column_path
	args34.ConsistencyLevel = consistency_level
	if err = args34.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGet() (value *ColumnOrSuperColumn, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error36 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error37 error
		error37, err = error36.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error37
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	result35 := NewGetResult()
	if err = result35.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result35.Ire != nil {
		err = result35.Ire
		return
	} else if result35.Nfe != nil {
		err = result35.Nfe
		return
	} else if result35.Ue != nil {
		err = result35.Ue
		return
	} else if result35.Te != nil {
		err = result35.Te
		return
	}
	value = result35.Success
	return
}

// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, err error) {
	if err = p.sendGetSlice(key, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetSlice()
}

func (p *CassandraClient) sendGetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_slice", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args38 := NewGetSliceArgs()
	args38.Key = key
	args38.ColumnParent = column_parent
	args38.Predicate = predicate
	args38.ConsistencyLevel = consistency_level
	if err = args38.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetSlice() (value []*ColumnOrSuperColumn, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error40 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error41 error
		error41, err = error40.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error41
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_slice failed: out of sequence response")
		return
	}
	result39 := NewGetSliceResult()
	if err = result39.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result39.Ire != nil {
		err = result39.Ire
		return
	} else if result39.Ue != nil {
		err = result39.Ue
		return
	} else if result39.Te != nil {
		err = result39.Te
		return
	}
	value = result39.Success
	return
}

// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, err error) {
	if err = p.sendGetCount(key, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetCount()
}

func (p *CassandraClient) sendGetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_count", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args42 := NewGetCountArgs()
	args42.Key = key
	args42.ColumnParent = column_parent
	args42.Predicate = predicate
	args42.ConsistencyLevel = consistency_level
	if err = args42.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetCount() (value int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error44 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error45 error
		error45, err = error44.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error45
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_count failed: out of sequence response")
		return
	}
	result43 := NewGetCountResult()
	if err = result43.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result43.Ire != nil {
		err = result43.Ire
		return
	} else if result43.Ue != nil {
		err = result43.Ue
		return
	} else if result43.Te != nil {
		err = result43.Te
		return
	}
	value = result43.Success
	return
}

// Performs a get_slice for column_parent and predicate for the given keys in parallel.
//
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, err error) {
	if err = p.sendMultigetSlice(keys, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvMultigetSlice()
}

func (p *CassandraClient) sendMultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("multiget_slice", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args46 := NewMultigetSliceArgs()
	args46.Keys = keys
	args46.ColumnParent = column_parent
	args46.Predicate = predicate
	args46.ConsistencyLevel = consistency_level
	if err = args46.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvMultigetSlice() (value map[string][]*ColumnOrSuperColumn, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error48 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error49 error
		error49, err = error48.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error49
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "multiget_slice failed: out of sequence response")
		return
	}
	result47 := NewMultigetSliceResult()
	if err = result47.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result47.Ire != nil {
		err = result47.Ire
		return
	} else if result47.Ue != nil {
		err = result47.Ue
		return
	} else if result47.Te != nil {
		err = result47.Te
		return
	}
	value = result47.Success
	return
}

// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
//
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, err error) {
	if err = p.sendMultigetCount(keys, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvMultigetCount()
}

func (p *CassandraClient) sendMultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("multiget_count", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args50 := NewMultigetCountArgs()
	args50.Keys = keys
	args50.ColumnParent = column_parent
	args50.Predicate = predicate
	args50.ConsistencyLevel = consistency_level
	if err = args50.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvMultigetCount() (value map[string]int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error52 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error53 error
		error53, err = error52.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error53
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "multiget_count failed: out of sequence response")
		return
	}
	result51 := NewMultigetCountResult()
	if err = result51.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result51.Ire != nil {
		err = result51.Ire
		return
	} else if result51.Ue != nil {
		err = result51.Ue
		return
	} else if result51.Te != nil {
		err = result51.Te
		return
	}
	value = result51.Success
	return
}

// returns a subset of columns for a contiguous range of keys.
//
// Parameters:
//  - ColumnParent
//  - Predicate
//  - RangeA1
//  - ConsistencyLevel
func (p *CassandraClient) GetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
	if err = p.sendGetRangeSlices(column_parent, predicate, range_a1, consistency_level); err != nil {
		return
	}
	return p.recvGetRangeSlices()
}

func (p *CassandraClient) sendGetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_range_slices", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args54 := NewGetRangeSlicesArgs()
	args54.ColumnParent = column_parent
	args54.Predicate = predicate
	args54.RangeA1 = range_a1
	args54.ConsistencyLevel = consistency_level
	if err = args54.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetRangeSlices() (value []*KeySlice, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error56 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error57 error
		error57, err = error56.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error57
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_range_slices failed: out of sequence response")
		return
	}
	result55 := NewGetRangeSlicesResult()
	if err = result55.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result55.Ire != nil {
		err = result55.Ire
		return
	} else if result55.Ue != nil {
		err = result55.Ue
		return
	} else if result55.Te != nil {
		err = result55.Te
		return
	}
	value = result55.Success
	return
}

// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
//
// Parameters:
//  - ColumnParent
//  - IndexClause
//  - ColumnPredicate
//  - ConsistencyLevel
func (p *CassandraClient) GetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
	if err = p.sendGetIndexedSlices(column_parent, index_clause, column_predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetIndexedSlices()
}

func (p *CassandraClient) sendGetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_indexed_slices", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args58 := NewGetIndexedSlicesArgs()
	args58.ColumnParent = column_parent
	args58.IndexClause = index_clause
	args58.ColumnPredicate = column_predicate
	args58.ConsistencyLevel = consistency_level
	if err = args58.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetIndexedSlices() (value []*KeySlice, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error60 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error61 error
		error61, err = error60.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error61
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_indexed_slices failed: out of sequence response")
		return
	}
	result59 := NewGetIndexedSlicesResult()
	if err = result59.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result59.Ire != nil {
		err = result59.Ire
		return
	} else if result59.Ue != nil {
		err = result59.Ue
		return
	} else if result59.Te != nil {
		err = result59.Te
		return
	}
	value = result59.Success
	return
}

// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Insert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendInsert(key, column_parent, column, consistency_level); err != nil {
		return
	}
	return p.recvInsert()
}

func (p *CassandraClient) sendInsert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("insert", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args62 := NewInsertArgs()
	args62.Key = key
	args62.ColumnParent = column_parent
	args62.Column = column
	args62.ConsistencyLevel = consistency_level
	if err = args62.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvInsert() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error64 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error65 error
		error65, err = error64.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error65
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "insert failed: out of sequence response")
		return
	}
	result63 := NewInsertResult()
	if err = result63.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result63.Ire != nil {
		err = result63.Ire
		return
	} else if result63.Ue != nil {
		err = result63.Ue
		return
	} else if result63.Te != nil {
		err = result63.Te
		return
	}
	return
}

// Increment or decrement a counter.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Add(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendAdd(key, column_parent, column, consistency_level); err != nil {
		return
	}
	return p.recvAdd()
}

func (p *CassandraClient) sendAdd(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("add", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args66 := NewAddArgs()
	args66.Key = key
	args66.ColumnParent = column_parent
	args66.Column = column
	args66.ConsistencyLevel = consistency_level
	if err = args66.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvAdd() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error68 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error69 error
		error69, err = error68.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error69
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "add failed: out of sequence response")
		return
	}
	result67 := NewAddResult()
	if err = result67.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result67.Ire != nil {
		err = result67.Ire
		return
	} else if result67.Ue != nil {
		err = result67.Ue
		return
	} else if result67.Te != nil {
		err = result67.Te
		return
	}
	return
}

// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
//
// Parameters:
//  - Key
//  - ColumnPath
//  - Timestamp
//  - ConsistencyLevel
func (p *CassandraClient) Remove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendRemove(key, column_path, timestamp, consistency_level); err != nil {
		return
	}
	return p.recvRemove()
}

func (p *CassandraClient) sendRemove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("remove", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args70 := NewRemoveArgs()
	args70.Key = key
	args70.ColumnPath = column_path
	args70.Timestamp = timestamp
	args70.ConsistencyLevel = consistency_level
	if err = args70.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvRemove() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error72 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error73 error
		error73, err = error72.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error73
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "remove failed: out of sequence response")
		return
	}
	result71 := NewRemoveResult()
	if err = result71.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result71.Ire != nil {
		err = result71.Ire
		return
	} else if result71.Ue != nil {
		err = result71.Ue
		return
	} else if result71.Te != nil {
		err = result71.Te
		return
	}
	return
}

// Remove a counter at the specified location.
// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
// until the delete has reached all the nodes and all of them have been fully compacted.
//
// Parameters:
//  - Key
//  - Path
//  - ConsistencyLevel
func (p *CassandraClient) RemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendRemoveCounter(key, path, consistency_level); err != nil {
		return
	}
	return p.recvRemoveCounter()
}

func (p *CassandraClient) sendRemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("remove_counter", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args74 := NewRemoveCounterArgs()
	args74.Key = key
	args74.Path = path
	args74.ConsistencyLevel = consistency_level
	if err = args74.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvRemoveCounter() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error76 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error77 error
		error77, err = error76.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error77
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "remove_counter failed: out of sequence response")
		return
	}
	result75 := NewRemoveCounterResult()
	if err = result75.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result75.Ire != nil {
		err = result75.Ire
		return
	} else if result75.Ue != nil {
		err = result75.Ue
		return
	} else if result75.Te != nil {
		err = result75.Te
		return
	}
	return
}

//   Mutate many columns or super columns for many row keys. See also: Mutation.
//
//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
// *
//
// Parameters:
//  - MutationMap
//  - ConsistencyLevel
func (p *CassandraClient) BatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendBatchMutate(mutation_map, consistency_level); err != nil {
		return
	}
	return p.recvBatchMutate()
}

func (p *CassandraClient) sendBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("batch_mutate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args78 := NewBatchMutateArgs()
	args78.MutationMap = mutation_map
	args78.ConsistencyLevel = consistency_level
	if err = args78.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvBatchMutate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error80 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error81 error
		error81, err = error80.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error81
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "batch_mutate failed: out of sequence response")
		return
	}
	result79 := NewBatchMutateResult()
	if err = result79.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result79.Ire != nil {
		err = result79.Ire
		return
	} else if result79.Ue != nil {
		err = result79.Ue
		return
	} else if result79.Te != nil {
		err = result79.Te
		return
	}
	return
}

// Truncate will mark and entire column family as deleted.
// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
// only marks the data as deleted.
// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
// some hosts are down.
//
// Parameters:
//  - Cfname
func (p *CassandraClient) Truncate(cfname string) (err error) {
	if err = p.sendTruncate(cfname); err != nil {
		return
	}
	return p.recvTruncate()
}

func (p *CassandraClient) sendTruncate(cfname string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("truncate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args82 := NewTruncateArgs()
	args82.Cfname = cfname
	if err = args82.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvTruncate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error84 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error85 error
		error85, err = error84.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error85
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "truncate failed: out of sequence response")
		return
	}
	result83 := NewTruncateResult()
	if err = result83.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result83.Ire != nil {
		err = result83.Ire
		return
	} else if result83.Ue != nil {
		err = result83.Ue
		return
	} else if result83.Te != nil {
		err = result83.Te
		return
	}
	return
}

// for each schema version present in the cluster, returns a list of nodes at that version.
// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
// the cluster is all on the same version if the size of the map is 1.
func (p *CassandraClient) DescribeSchemaVersions() (r map[string][]string, err error) {
	if err = p.sendDescribeSchemaVersions(); err != nil {
		return
	}
	return p.recvDescribeSchemaVersions()
}

func (p *CassandraClient) sendDescribeSchemaVersions() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_schema_versions", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args86 := NewDescribeSchemaVersionsArgs()
	if err = args86.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSchemaVersions() (value map[string][]string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error88 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error89 error
		error89, err = error88.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error89
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_schema_versions failed: out of sequence response")
		return
	}
	result87 := NewDescribeSchemaVersionsResult()
	if err = result87.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result87.Ire != nil {
		err = result87.Ire
		return
	}
	value = result87.Success
	return
}

// list the defined keyspaces in this cluster
func (p *CassandraClient) DescribeKeyspaces() (r []*KsDef, err error) {
	if err = p.sendDescribeKeyspaces(); err != nil {
		return
	}
	return p.recvDescribeKeyspaces()
}

func (p *CassandraClient) sendDescribeKeyspaces() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_keyspaces", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args90 := NewDescribeKeyspacesArgs()
	if err = args90.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeKeyspaces() (value []*KsDef, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error92 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error93 error
		error93, err = error92.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error93
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_keyspaces failed: out of sequence response")
		return
	}
	result91 := NewDescribeKeyspacesResult()
	if err = result91.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result91.Ire != nil {
		err = result91.Ire
		return
	}
	value = result91.Success
	return
}

// get the cluster name
func (p *CassandraClient) DescribeClusterName() (r string, err error) {
	if err = p.sendDescribeClusterName(); err != nil {
		return
	}
	return p.recvDescribeClusterName()
}

func (p *CassandraClient) sendDescribeClusterName() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_cluster_name", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args94 := NewDescribeClusterNameArgs()
	if err = args94.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeClusterName() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error96 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error97 error
		error97, err = error96.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error97
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_cluster_name failed: out of sequence response")
		return
	}
	result95 := NewDescribeClusterNameResult()
	if err = result95.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result95.Success
	return
}

// get the thrift api version
func (p *CassandraClient) DescribeVersion() (r string, err error) {
	if err = p.sendDescribeVersion(); err != nil {
		return
	}
	return p.recvDescribeVersion()
}

func (p *CassandraClient) sendDescribeVersion() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_version", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args98 := NewDescribeVersionArgs()
	if err = args98.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeVersion() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error100 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error101 error
		error101, err = error100.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error101
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_version failed: out of sequence response")
		return
	}
	result99 := NewDescribeVersionResult()
	if err = result99.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result99.Success
	return
}

// get the token ring: a map of ranges to host addresses,
// represented as a set of TokenRange instead of a map from range
// to list of endpoints, because you can't use Thrift structs as
// map keys:
// https://issues.apache.org/jira/browse/THRIFT-162
//
// for the same reason, we can't return a set here, even though
// order is neither important nor predictable.
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeRing(keyspace string) (r []*TokenRange, err error) {
	if err = p.sendDescribeRing(keyspace); err != nil {
		return
	}
	return p.recvDescribeRing()
}

func (p *CassandraClient) sendDescribeRing(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_ring", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args102 := NewDescribeRingArgs()
	args102.Keyspace = keyspace
	if err = args102.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeRing() (value []*TokenRange, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error104 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error105 error
		error105, err = error104.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error105
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_ring failed: out of sequence response")
		return
	}
	result103 := NewDescribeRingResult()
	if err = result103.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result103.Ire != nil {
		err = result103.Ire
		return
	}
	value = result103.Success
	return
}

// returns the partitioner used by this cluster
func (p *CassandraClient) DescribePartitioner() (r string, err error) {
	if err = p.sendDescribePartitioner(); err != nil {
		return
	}
	return p.recvDescribePartitioner()
}

func (p *CassandraClient) sendDescribePartitioner() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_partitioner", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args106 := NewDescribePartitionerArgs()
	if err = args106.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribePartitioner() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error108 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error109 error
		error109, err = error108.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error109
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_partitioner failed: out of sequence response")
		return
	}
	result107 := NewDescribePartitionerResult()
	if err = result107.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result107.Success
	return
}

// returns the snitch used by this cluster
func (p *CassandraClient) DescribeSnitch() (r string, err error) {
	if err = p.sendDescribeSnitch(); err != nil {
		return
	}
	return p.recvDescribeSnitch()
}

func (p *CassandraClient) sendDescribeSnitch() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_snitch", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args110 := NewDescribeSnitchArgs()
	if err = args110.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSnitch() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error112 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error113 error
		error113, err = error112.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error113
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_snitch failed: out of sequence response")
		return
	}
	result111 := NewDescribeSnitchResult()
	if err = result111.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result111.Success
	return
}

// describe specified keyspace
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeKeyspace(keyspace string) (r *KsDef, err error) {
	if err = p.sendDescribeKeyspace(keyspace); err != nil {
		return
	}
	return p.recvDescribeKeyspace()
}

func (p *CassandraClient) sendDescribeKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args114 := NewDescribeKeyspaceArgs()
	args114.Keyspace = keyspace
	if err = args114.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeKeyspace() (value *KsDef, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error116 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error117 error
		error117, err = error116.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error117
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_keyspace failed: out of sequence response")
		return
	}
	result115 := NewDescribeKeyspaceResult()
	if err = result115.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result115.Nfe != nil {
		err = result115.Nfe
		return
	} else if result115.Ire != nil {
		err = result115.Ire
		return
	}
	value = result115.Success
	return
}

// experimental API for hadoop/parallel query support.
// may change violently and without warning.
//
// returns list of token strings such that first subrange is (list[0], list[1]],
// next is (list[1], list[2]], etc.
//
// Parameters:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
func (p *CassandraClient) DescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (r []string, err error) {
	if err = p.sendDescribeSplits(cfName, start_token, end_token, keys_per_split); err != nil {
		return
	}
	return p.recvDescribeSplits()
}

func (p *CassandraClient) sendDescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_splits", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args118 := NewDescribeSplitsArgs()
	args118.CfName = cfName
	args118.StartToken = start_token
	args118.EndToken = end_token
	args118.KeysPerSplit = keys_per_split
	if err = args118.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSplits() (value []string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error120 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error121 error
		error121, err = error120.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error121
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_splits failed: out of sequence response")
		return
	}
	result119 := NewDescribeSplitsResult()
	if err = result119.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result119.Ire != nil {
		err = result119.Ire
		return
	}
	value = result119.Success
	return
}

// adds a column family. returns the new schema id.
//
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemAddColumnFamily(cf_def *CfDef) (r string, err error) {
	if err = p.sendSystemAddColumnFamily(cf_def); err != nil {
		return
	}
	return p.recvSystemAddColumnFamily()
}

func (p *CassandraClient) sendSystemAddColumnFamily(cf_def *CfDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_add_column_family", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args122 := NewSystemAddColumnFamilyArgs()
	args122.CfDef = cf_def
	if err = args122.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemAddColumnFamily() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error124 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error125 error
		error125, err = error124.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error125
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_add_column_family failed: out of sequence response")
		return
	}
	result123 := NewSystemAddColumnFamilyResult()
	if err = result123.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result123.Ire != nil {
		err = result123.Ire
		return
	} else if result123.Sde != nil {
		err = result123.Sde
		return
	}
	value = result123.Success
	return
}

// drops a column family. returns the new schema id.
//
// Parameters:
//  - ColumnFamily
func (p *CassandraClient) SystemDropColumnFamily(column_family string) (r string, err error) {
	if err = p.sendSystemDropColumnFamily(column_family); err != nil {
		return
	}
	return p.recvSystemDropColumnFamily()
}

func (p *CassandraClient) sendSystemDropColumnFamily(column_family string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_drop_column_family", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args126 := NewSystemDropColumnFamilyArgs()
	args126.ColumnFamily = column_family
	if err = args126.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemDropColumnFamily() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error128 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error129 error
		error129, err = error128.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error129
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_drop_column_family failed: out of sequence response")
		return
	}
	result127 := NewSystemDropColumnFamilyResult()
	if err = result127.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result127.Ire != nil {
		err = result127.Ire
		return
	} else if result127.Sde != nil {
		err = result127.Sde
		return
	}
	value = result127.Success
	return
}

// adds a keyspace and any column families that are part of it. returns the new schema id.
//
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemAddKeyspace(ks_def *KsDef) (r string, err error) {
	if err = p.sendSystemAddKeyspace(ks_def); err != nil {
		return
	}
	return p.recvSystemAddKeyspace()
}

func (p *CassandraClient) sendSystemAddKeyspace(ks_def *KsDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_add_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args130 := NewSystemAddKeyspaceArgs()
	args130.KsDef = ks_def
	if err = args130.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemAddKeyspace() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error132 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error133 error
		error133, err = error132.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error133
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_add_keyspace failed: out of sequence response")
		return
	}
	result131 := NewSystemAddKeyspaceResult()
	if err = result131.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result131.Ire != nil {
		err = result131.Ire
		return
	} else if result131.Sde != nil {
		err = result131.Sde
		return
	}
	value = result131.Success
	return
}

// drops a keyspace and any column families that are part of it. returns the new schema id.
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) SystemDropKeyspace(keyspace string) (r string, err error) {
	if err = p.sendSystemDropKeyspace(keyspace); err != nil {
		return
	}
	return p.recvSystemDropKeyspace()
}

func (p *CassandraClient) sendSystemDropKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_drop_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args134 := NewSystemDropKeyspaceArgs()
	args134.Keyspace = keyspace
	if err = args134.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemDropKeyspace() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error136 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error137 error
		error137, err = error136.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error137
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_drop_keyspace failed: out of sequence response")
		return
	}
	result135 := NewSystemDropKeyspaceResult()
	if err = result135.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result135.Ire != nil {
		err = result135.Ire
		return
	} else if result135.Sde != nil {
		err = result135.Sde
		return
	}
	value = result135.Success
	return
}

// updates properties of a keyspace. returns the new schema id.
//
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemUpdateKeyspace(ks_def *KsDef) (r string, err error) {
	if err = p.sendSystemUpdateKeyspace(ks_def); err != nil {
		return
	}
	return p.recvSystemUpdateKeyspace()
}

func (p *CassandraClient) sendSystemUpdateKeyspace(ks_def *KsDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_update_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args138 := NewSystemUpdateKeyspaceArgs()
	args138.KsDef = ks_def
	if err = args138.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemUpdateKeyspace() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error140 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error141 error
		error141, err = error140.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error141
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_update_keyspace failed: out of sequence response")
		return
	}
	result139 := NewSystemUpdateKeyspaceResult()
	if err = result139.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result139.Ire != nil {
		err = result139.Ire
		return
	} else if result139.Sde != nil {
		err = result139.Sde
		return
	}
	value = result139.Success
	return
}

// updates properties of a column family. returns the new schema id.
//
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemUpdateColumnFamily(cf_def *CfDef) (r string, err error) {
	if err = p.sendSystemUpdateColumnFamily(cf_def); err != nil {
		return
	}
	return p.recvSystemUpdateColumnFamily()
}

func (p *CassandraClient) sendSystemUpdateColumnFamily(cf_def *CfDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_update_column_family", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args142 := NewSystemUpdateColumnFamilyArgs()
	args142.CfDef = cf_def
	if err = args142.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemUpdateColumnFamily() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error144 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error145 error
		error145, err = error144.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error145
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_update_column_family failed: out of sequence response")
		return
	}
	result143 := NewSystemUpdateColumnFamilyResult()
	if err = result143.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result143.Ire != nil {
		err = result143.Ire
		return
	} else if result143.Sde != nil {
		err = result143.Sde
		return
	}
	value = result143.Success
	return
}

// Executes a CQL (Cassandra Query Language) statement and returns a
// CqlResult containing the results.
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) ExecuteCqlQuery(query []byte, compression Compression) (r *CqlResult, err error) {
	if err = p.sendExecuteCqlQuery(query, compression); err != nil {
		return
	}
	return p.recvExecuteCqlQuery()
}

func (p *CassandraClient) sendExecuteCqlQuery(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_cql_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args146 := NewExecuteCqlQueryArgs()
	args146.Query = query
	args146.Compression = compression
	if err = args146.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecuteCqlQuery() (value *CqlResult, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error148 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error149 error
		error149, err = error148.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error149
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_cql_query failed: out of sequence response")
		return
	}
	result147 := NewExecuteCqlQueryResult()
	if err = result147.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result147.Ire != nil {
		err = result147.Ire
		return
	} else if result147.Ue != nil {
		err = result147.Ue
		return
	} else if result147.Te != nil {
		err = result147.Te
		return
	} else if result147.Sde != nil {
		err = result147.Sde
		return
	}
	value = result147.Success
	return
}

// Prepare a CQL (Cassandra Query Language) statement by compiling and returning
// - the type of CQL statement
// - an id token of the compiled CQL stored on the server side.
// - a count of the discovered bound markers in the statement
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) PrepareCqlQuery(query []byte, compression Compression) (r *CqlPreparedResult, err error) {
	if err = p.sendPrepareCqlQuery(query, compression); err != nil {
		return
	}
	return p.recvPrepareCqlQuery()
}

func (p *CassandraClient) sendPrepareCqlQuery(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("prepare_cql_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args150 := NewPrepareCqlQueryArgs()
	args150.Query = query
	args150.Compression = compression
	if err = args150.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvPrepareCqlQuery() (value *CqlPreparedResult, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error152 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error153 error
		error153, err = error152.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error153
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "prepare_cql_query failed: out of sequence response")
		return
	}
	result151 := NewPrepareCqlQueryResult()
	if err = result151.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result151.Ire != nil {
		err = result151.Ire
		return
	}
	value = result151.Success
	return
}

// Executes a prepared CQL (Cassandra Query Language) statement by passing an id token and  a list of variables
// to bind and returns a CqlResult containing the results.
//
// Parameters:
//  - ItemId
//  - Values
func (p *CassandraClient) ExecutePreparedCqlQuery(itemId int32, values []string) (r *CqlResult, err error) {
	if err = p.sendExecutePreparedCqlQuery(itemId, values); err != nil {
		return
	}
	return p.recvExecutePreparedCqlQuery()
}

func (p *CassandraClient) sendExecutePreparedCqlQuery(itemId int32, values []string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args154 := NewExecutePreparedCqlQueryArgs()
	args154.ItemId = itemId
	args154.Values = values
	if err = args154.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecutePreparedCqlQuery() (value *CqlResult, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error156 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error157 error
		error157, err = error156.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error157
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_prepared_cql_query failed: out of sequence response")
		return
	}
	result155 := NewExecutePreparedCqlQueryResult()
	if err = result155.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result155.Ire != nil {
		err = result155.Ire
		return
	} else if result155.Ue != nil {
		err = result155.Ue
		return
	} else if result155.Te != nil {
		err = result155.Te
		return
	} else if result155.Sde != nil {
		err = result155.Sde
		return
	}
	value = result155.Success
	return
}

type CassandraProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Cassandra
}

func (p *CassandraProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *CassandraProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *CassandraProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewCassandraProcessor(handler Cassandra) *CassandraProcessor {

	self158 := &CassandraProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self158.processorMap["login"] = &cassandraProcessorLogin{handler: handler}
	self158.processorMap["set_keyspace"] = &cassandraProcessorSetKeyspace{handler: handler}
	self158.processorMap["get"] = &cassandraProcessorGet{handler: handler}
	self158.processorMap["get_slice"] = &cassandraProcessorGetSlice{handler: handler}
	self158.processorMap["get_count"] = &cassandraProcessorGetCount{handler: handler}
	self158.processorMap["multiget_slice"] = &cassandraProcessorMultigetSlice{handler: handler}
	self158.processorMap["multiget_count"] = &cassandraProcessorMultigetCount{handler: handler}
	self158.processorMap["get_range_slices"] = &cassandraProcessorGetRangeSlices{handler: handler}
	self158.processorMap["get_indexed_slices"] = &cassandraProcessorGetIndexedSlices{handler: handler}
	self158.processorMap["insert"] = &cassandraProcessorInsert{handler: handler}
	self158.processorMap["add"] = &cassandraProcessorAdd{handler: handler}
	self158.processorMap["remove"] = &cassandraProcessorRemove{handler: handler}
	self158.processorMap["remove_counter"] = &cassandraProcessorRemoveCounter{handler: handler}
	self158.processorMap["batch_mutate"] = &cassandraProcessorBatchMutate{handler: handler}
	self158.processorMap["truncate"] = &cassandraProcessorTruncate{handler: handler}
	self158.processorMap["describe_schema_versions"] = &cassandraProcessorDescribeSchemaVersions{handler: handler}
	self158.processorMap["describe_keyspaces"] = &cassandraProcessorDescribeKeyspaces{handler: handler}
	self158.processorMap["describe_cluster_name"] = &cassandraProcessorDescribeClusterName{handler: handler}
	self158.processorMap["describe_version"] = &cassandraProcessorDescribeVersion{handler: handler}
	self158.processorMap["describe_ring"] = &cassandraProcessorDescribeRing{handler: handler}
	self158.processorMap["describe_partitioner"] = &cassandraProcessorDescribePartitioner{handler: handler}
	self158.processorMap["describe_snitch"] = &cassandraProcessorDescribeSnitch{handler: handler}
	self158.processorMap["describe_keyspace"] = &cassandraProcessorDescribeKeyspace{handler: handler}
	self158.processorMap["describe_splits"] = &cassandraProcessorDescribeSplits{handler: handler}
	self158.processorMap["system_add_column_family"] = &cassandraProcessorSystemAddColumnFamily{handler: handler}
	self158.processorMap["system_drop_column_family"] = &cassandraProcessorSystemDropColumnFamily{handler: handler}
	self158.processorMap["system_add_keyspace"] = &cassandraProcessorSystemAddKeyspace{handler: handler}
	self158.processorMap["system_drop_keyspace"] = &cassandraProcessorSystemDropKeyspace{handler: handler}
	self158.processorMap["system_update_keyspace"] = &cassandraProcessorSystemUpdateKeyspace{handler: handler}
	self158.processorMap["system_update_column_family"] = &cassandraProcessorSystemUpdateColumnFamily{handler: handler}
	self158.processorMap["execute_cql_query"] = &cassandraProcessorExecuteCqlQuery{handler: handler}
	self158.processorMap["prepare_cql_query"] = &cassandraProcessorPrepareCqlQuery{handler: handler}
	self158.processorMap["execute_prepared_cql_query"] = &cassandraProcessorExecutePreparedCqlQuery{handler: handler}
	return self158
}

func (p *CassandraProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x159 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x159.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x159

}

type cassandraProcessorLogin struct {
	handler Cassandra
}

func (p *cassandraProcessorLogin) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewLoginArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewLoginResult()
	var err2 error
	if err2 = p.handler.Login(args.AuthRequest); err2 != nil {
		switch v := err2.(type) {
		case *AuthenticationException:
			result.Authnx = v
		case *AuthorizationException:
			result.Authzx = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing login: "+err.Error())
			oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("login", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSetKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSetKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetKeyspaceResult()
	var err2 error
	if err2 = p.handler.SetKeyspace(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_keyspace: "+err.Error())
			oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("set_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGet struct {
	handler Cassandra
}

func (p *cassandraProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetResult()
	var err2 error
	if result.Success, err2 = p.handler.Get(args.Key, args.ColumnPath, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *NotFoundException:
			result.Nfe = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorGetSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetSliceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetSliceResult()
	var err2 error
	if result.Success, err2 = p.handler.GetSlice(args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_slice: "+err.Error())
			oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetCount struct {
	handler Cassandra
}

func (p *cassandraProcessorGetCount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetCountArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetCountResult()
	var err2 error
	if result.Success, err2 = p.handler.GetCount(args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_count: "+err.Error())
			oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get_count", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorMultigetSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorMultigetSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMultigetSliceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMultigetSliceResult()
	var err2 error
	if result.Success, err2 = p.handler.MultigetSlice(args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_slice: "+err.Error())
			oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("multiget_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorMultigetCount struct {
	handler Cassandra
}

func (p *cassandraProcessorMultigetCount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMultigetCountArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMultigetCountResult()
	var err2 error
	if result.Success, err2 = p.handler.MultigetCount(args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_count: "+err.Error())
			oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("multiget_count", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetRangeSlices struct {
	handler Cassandra
}

func (p *cassandraProcessorGetRangeSlices) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRangeSlicesArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRangeSlicesResult()
	var err2 error
	if result.Success, err2 = p.handler.GetRangeSlices(args.ColumnParent, args.Predicate, args.RangeA1, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_range_slices: "+err.Error())
			oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get_range_slices", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetIndexedSlices struct {
	handler Cassandra
}

func (p *cassandraProcessorGetIndexedSlices) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetIndexedSlicesArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetIndexedSlicesResult()
	var err2 error
	if result.Success, err2 = p.handler.GetIndexedSlices(args.ColumnParent, args.IndexClause, args.ColumnPredicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_indexed_slices: "+err.Error())
			oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get_indexed_slices", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorInsert struct {
	handler Cassandra
}

func (p *cassandraProcessorInsert) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewInsertArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewInsertResult()
	var err2 error
	if err2 = p.handler.Insert(args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing insert: "+err.Error())
			oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("insert", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorAdd struct {
	handler Cassandra
}

func (p *cassandraProcessorAdd) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAddArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAddResult()
	var err2 error
	if err2 = p.handler.Add(args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing add: "+err.Error())
			oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("add", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorRemove struct {
	handler Cassandra
}

func (p *cassandraProcessorRemove) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRemoveArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRemoveResult()
	var err2 error
	if err2 = p.handler.Remove(args.Key, args.ColumnPath, args.Timestamp, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove: "+err.Error())
			oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("remove", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorRemoveCounter struct {
	handler Cassandra
}

func (p *cassandraProcessorRemoveCounter) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRemoveCounterArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRemoveCounterResult()
	var err2 error
	if err2 = p.handler.RemoveCounter(args.Key, args.Path, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove_counter: "+err.Error())
			oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("remove_counter", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorBatchMutate struct {
	handler Cassandra
}

func (p *cassandraProcessorBatchMutate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewBatchMutateArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewBatchMutateResult()
	var err2 error
	if err2 = p.handler.BatchMutate(args.MutationMap, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing batch_mutate: "+err.Error())
			oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("batch_mutate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorTruncate struct {
	handler Cassandra
}

func (p *cassandraProcessorTruncate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTruncateArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTruncateResult()
	var err2 error
	if err2 = p.handler.Truncate(args.Cfname); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncate: "+err.Error())
			oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("truncate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSchemaVersions struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSchemaVersions) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeSchemaVersionsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeSchemaVersionsResult()
	var err2 error
	if result.Success, err2 = p.handler.DescribeSchemaVersions(); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_schema_versions: "+err.Error())
			oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_schema_versions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeKeyspaces struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspaces) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeKeyspacesArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeKeyspacesResult()
	var err2 error
	if result.Success, err2 = p.handler.DescribeKeyspaces(); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspaces: "+err.Error())
			oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_keyspaces", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeClusterName struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeClusterName) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeClusterNameArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeClusterNameResult()
	var err2 error
	if result.Success, err2 = p.handler.DescribeClusterName(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_cluster_name: "+err.Error())
		oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err2
	}
	if err2 = oprot.WriteMessageBegin("describe_cluster_name", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeVersion struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeVersionArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeVersionResult()
	var err2 error
	if result.Success, err2 = p.handler.DescribeVersion(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_version: "+err.Error())
		oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err2
	}
	if err2 = oprot.WriteMessageBegin("describe_version", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeRing struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeRing) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeRingArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeRingResult()
	var err2 error
	if result.Success, err2 = p.handler.DescribeRing(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_ring: "+err.Error())
			oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_ring", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribePartitioner struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribePartitioner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribePartitionerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribePartitionerResult()
	var err2 error
	if result.Success, err2 = p.handler.DescribePartitioner(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_partitioner: "+err.Error())
		oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err2
	}
	if err2 = oprot.WriteMessageBegin("describe_partitioner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSnitch struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSnitch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeSnitchArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeSnitchResult()
	var err2 error
	if result.Success, err2 = p.handler.DescribeSnitch(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_snitch: "+err.Error())
		oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err2
	}
	if err2 = oprot.WriteMessageBegin("describe_snitch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeKeyspaceResult()
	var err2 error
	if result.Success, err2 = p.handler.DescribeKeyspace(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *NotFoundException:
			result.Nfe = v
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspace: "+err.Error())
			oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSplits struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSplits) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeSplitsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeSplitsResult()
	var err2 error
	if result.Success, err2 = p.handler.DescribeSplits(args.CfName, args.StartToken, args.EndToken, args.KeysPerSplit); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_splits: "+err.Error())
			oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_splits", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemAddColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemAddColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemAddColumnFamilyArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemAddColumnFamilyResult()
	var err2 error
	if result.Success, err2 = p.handler.SystemAddColumnFamily(args.CfDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_column_family: "+err.Error())
			oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("system_add_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemDropColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemDropColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemDropColumnFamilyArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemDropColumnFamilyResult()
	var err2 error
	if result.Success, err2 = p.handler.SystemDropColumnFamily(args.ColumnFamily); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_column_family: "+err.Error())
			oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("system_drop_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemAddKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemAddKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemAddKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemAddKeyspaceResult()
	var err2 error
	if result.Success, err2 = p.handler.SystemAddKeyspace(args.KsDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_keyspace: "+err.Error())
			oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("system_add_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemDropKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemDropKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemDropKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemDropKeyspaceResult()
	var err2 error
	if result.Success, err2 = p.handler.SystemDropKeyspace(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_keyspace: "+err.Error())
			oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("system_drop_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemUpdateKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemUpdateKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemUpdateKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemUpdateKeyspaceResult()
	var err2 error
	if result.Success, err2 = p.handler.SystemUpdateKeyspace(args.KsDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_keyspace: "+err.Error())
			oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("system_update_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemUpdateColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemUpdateColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemUpdateColumnFamilyArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemUpdateColumnFamilyResult()
	var err2 error
	if result.Success, err2 = p.handler.SystemUpdateColumnFamily(args.CfDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_column_family: "+err.Error())
			oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("system_update_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecuteCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorExecuteCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewExecuteCqlQueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewExecuteCqlQueryResult()
	var err2 error
	if result.Success, err2 = p.handler.ExecuteCqlQuery(args.Query, args.Compression); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_cql_query: "+err.Error())
			oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("execute_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorPrepareCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorPrepareCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewPrepareCqlQueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewPrepareCqlQueryResult()
	var err2 error
	if result.Success, err2 = p.handler.PrepareCqlQuery(args.Query, args.Compression); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prepare_cql_query: "+err.Error())
			oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("prepare_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecutePreparedCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorExecutePreparedCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewExecutePreparedCqlQueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewExecutePreparedCqlQueryResult()
	var err2 error
	if result.Success, err2 = p.handler.ExecutePreparedCqlQuery(args.ItemId, args.Values); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_prepared_cql_query: "+err.Error())
			oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return false, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type LoginArgs struct {
	AuthRequest *AuthenticationRequest `thrift:"auth_request,1,required"`
}

func NewLoginArgs() *LoginArgs {
	rval := &LoginArgs{}
	return rval
}

func (p *LoginArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginArgs) readField1(iprot thrift.TProtocol) error {
	p.AuthRequest = NewAuthenticationRequest()
	if err := p.AuthRequest.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.AuthRequest, err)
	}
	return nil
}

func (p *LoginArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("login_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.AuthRequest != nil {
		if err := oprot.WriteFieldBegin("auth_request", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:auth_request: %s", p, err)
		}
		if err := p.AuthRequest.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.AuthRequest, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:auth_request: %s", p, err)
		}
	}
	return err
}

func (p *LoginArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginArgs(%+v)", *p)
}

type LoginResult struct {
	Authnx *AuthenticationException `thrift:"authnx,1"`
	Authzx *AuthorizationException  `thrift:"authzx,2"`
}

func NewLoginResult() *LoginResult {
	rval := &LoginResult{}
	return rval
}

func (p *LoginResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginResult) readField1(iprot thrift.TProtocol) error {
	p.Authnx = NewAuthenticationException()
	if err := p.Authnx.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Authnx, err)
	}
	return nil
}

func (p *LoginResult) readField2(iprot thrift.TProtocol) error {
	p.Authzx = NewAuthorizationException()
	if err := p.Authzx.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Authzx, err)
	}
	return nil
}

func (p *LoginResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("login_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Authzx != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Authnx != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Authnx != nil {
		if err := oprot.WriteFieldBegin("authnx", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:authnx: %s", p, err)
		}
		if err := p.Authnx.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Authnx, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:authnx: %s", p, err)
		}
	}
	return err
}

func (p *LoginResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Authzx != nil {
		if err := oprot.WriteFieldBegin("authzx", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:authzx: %s", p, err)
		}
		if err := p.Authzx.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Authzx, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:authzx: %s", p, err)
		}
	}
	return err
}

func (p *LoginResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginResult(%+v)", *p)
}

type SetKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required"`
}

func NewSetKeyspaceArgs() *SetKeyspaceArgs {
	rval := &SetKeyspaceArgs{}
	return rval
}

func (p *SetKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *SetKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SetKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *SetKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetKeyspaceArgs(%+v)", *p)
}

type SetKeyspaceResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
}

func NewSetKeyspaceResult() *SetKeyspaceResult {
	rval := &SetKeyspaceResult{}
	return rval
}

func (p *SetKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SetKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SetKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SetKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetKeyspaceResult(%+v)", *p)
}

type GetArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnPath       *ColumnPath      `thrift:"column_path,2,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required"`
}

func NewGetArgs() *GetArgs {
	rval := &GetArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnPath = NewColumnPath()
	if err := p.ColumnPath.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnPath, err)
	}
	return nil
}

func (p *GetArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnPath != nil {
		if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_path: %s", p, err)
		}
		if err := p.ColumnPath.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnPath, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_path: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success *ColumnOrSuperColumn     `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Nfe     *NotFoundException       `thrift:"nfe,2"`
	Ue      *UnavailableException    `thrift:"ue,3"`
	Te      *TimedOutException       `thrift:"te,4"`
}

func NewGetResult() *GetResult {
	rval := &GetResult{}
	return rval
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewColumnOrSuperColumn()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetResult) readField2(iprot thrift.TProtocol) error {
	p.Nfe = NewNotFoundException()
	if err := p.Nfe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Nfe, err)
	}
	return nil
}

func (p *GetResult) readField3(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetResult) readField4(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Nfe != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Nfe != nil {
		if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:nfe: %s", p, err)
		}
		if err := p.Nfe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Nfe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:nfe: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:te: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type GetSliceArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewGetSliceArgs() *GetSliceArgs {
	rval := &GetSliceArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *GetSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSliceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetSliceArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *GetSliceArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *GetSliceArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_slice_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSliceArgs(%+v)", *p)
}

type GetSliceResult struct {
	Success []*ColumnOrSuperColumn   `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewGetSliceResult() *GetSliceResult {
	rval := &GetSliceResult{}
	return rval
}

func (p *GetSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSliceResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*ColumnOrSuperColumn, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem160 := NewColumnOrSuperColumn()
		if err := _elem160.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem160, err)
		}
		p.Success = append(p.Success, _elem160)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetSliceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetSliceResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetSliceResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_slice_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSliceResult(%+v)", *p)
}

type GetCountArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewGetCountArgs() *GetCountArgs {
	rval := &GetCountArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *GetCountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCountArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetCountArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *GetCountArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *GetCountArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetCountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_count_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *GetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *GetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
		}
	}
	return err
}

func (p *GetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetCountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCountArgs(%+v)", *p)
}

type GetCountResult struct {
	Success int32                    `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewGetCountResult() *GetCountResult {
	rval := &GetCountResult{}
	return rval
}

func (p *GetCountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCountResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetCountResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetCountResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetCountResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetCountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_count_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCountResult(%+v)", *p)
}

type MultigetSliceArgs struct {
	Keys             [][]byte         `thrift:"keys,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewMultigetSliceArgs() *MultigetSliceArgs {
	rval := &MultigetSliceArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *MultigetSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetSliceArgs) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([][]byte, 0, size)
	p.Keys = tSlice
	for i := 0; i < size; i++ {
		var _elem161 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem161 = v
		}
		p.Keys = append(p.Keys, _elem161)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MultigetSliceArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *MultigetSliceArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *MultigetSliceArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *MultigetSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_slice_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Keys != nil {
		if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:keys: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Keys {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:keys: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *MultigetSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetSliceArgs(%+v)", *p)
}

type MultigetSliceResult struct {
	Success map[string][]*ColumnOrSuperColumn `thrift:"success,0"`
	Ire     *InvalidRequestException          `thrift:"ire,1"`
	Ue      *UnavailableException             `thrift:"ue,2"`
	Te      *TimedOutException                `thrift:"te,3"`
}

func NewMultigetSliceResult() *MultigetSliceResult {
	rval := &MultigetSliceResult{}
	return rval
}

func (p *MultigetSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetSliceResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string][]*ColumnOrSuperColumn, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key162 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key162 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s")
		}
		tSlice := make([]*ColumnOrSuperColumn, 0, size)
		_val163 := tSlice
		for i := 0; i < size; i++ {
			_elem164 := NewColumnOrSuperColumn()
			if err := _elem164.Read(iprot); err != nil {
				return fmt.Errorf("%T error reading struct: %s", _elem164, err)
			}
			_val163 = append(_val163, _elem164)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success[_key162] = _val163
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *MultigetSliceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *MultigetSliceResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *MultigetSliceResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *MultigetSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_slice_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Success {
			if err := oprot.WriteBinary([]byte(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetSliceResult(%+v)", *p)
}

type MultigetCountArgs struct {
	Keys             [][]byte         `thrift:"keys,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewMultigetCountArgs() *MultigetCountArgs {
	rval := &MultigetCountArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *MultigetCountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetCountArgs) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([][]byte, 0, size)
	p.Keys = tSlice
	for i := 0; i < size; i++ {
		var _elem165 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem165 = v
		}
		p.Keys = append(p.Keys, _elem165)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MultigetCountArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *MultigetCountArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *MultigetCountArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *MultigetCountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_count_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Keys != nil {
		if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:keys: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Keys {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:keys: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *MultigetCountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetCountArgs(%+v)", *p)
}

type MultigetCountResult struct {
	Success map[string]int32         `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewMultigetCountResult() *MultigetCountResult {
	rval := &MultigetCountResult{}
	return rval
}

func (p *MultigetCountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetCountResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string]int32, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key166 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key166 = v
		}
		var _val167 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val167 = v
		}
		p.Success[_key166] = _val167
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *MultigetCountResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *MultigetCountResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *MultigetCountResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *MultigetCountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_count_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.I32, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Success {
			if err := oprot.WriteBinary([]byte(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteI32(int32(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetCountResult(%+v)", *p)
}

type GetRangeSlicesArgs struct {
	ColumnParent     *ColumnParent    `thrift:"column_parent,1,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,2,required"`
	RangeA1          *KeyRange        `thrift:"range,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewGetRangeSlicesArgs() *GetRangeSlicesArgs {
	rval := &GetRangeSlicesArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *GetRangeSlicesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) readField1(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) readField2(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) readField3(iprot thrift.TProtocol) error {
	p.RangeA1 = NewKeyRange()
	if err := p.RangeA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.RangeA1, err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetRangeSlicesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_range_slices_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:predicate: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.RangeA1 != nil {
		if err := oprot.WriteFieldBegin("range", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:range: %s", p, err)
		}
		if err := p.RangeA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.RangeA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:range: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetRangeSlicesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRangeSlicesArgs(%+v)", *p)
}

type GetRangeSlicesResult struct {
	Success []*KeySlice              `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewGetRangeSlicesResult() *GetRangeSlicesResult {
	rval := &GetRangeSlicesResult{}
	return rval
}

func (p *GetRangeSlicesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRangeSlicesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*KeySlice, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem168 := NewKeySlice()
		if err := _elem168.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem168, err)
		}
		p.Success = append(p.Success, _elem168)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRangeSlicesResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetRangeSlicesResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetRangeSlicesResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetRangeSlicesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_range_slices_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRangeSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRangeSlicesResult(%+v)", *p)
}

type GetIndexedSlicesArgs struct {
	ColumnParent     *ColumnParent    `thrift:"column_parent,1,required"`
	IndexClause      *IndexClause     `thrift:"index_clause,2,required"`
	ColumnPredicate  *SlicePredicate  `thrift:"column_predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewGetIndexedSlicesArgs() *GetIndexedSlicesArgs {
	rval := &GetIndexedSlicesArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *GetIndexedSlicesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) readField1(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) readField2(iprot thrift.TProtocol) error {
	p.IndexClause = NewIndexClause()
	if err := p.IndexClause.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.IndexClause, err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) readField3(iprot thrift.TProtocol) error {
	p.ColumnPredicate = NewSlicePredicate()
	if err := p.ColumnPredicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnPredicate, err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetIndexedSlicesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_indexed_slices_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IndexClause != nil {
		if err := oprot.WriteFieldBegin("index_clause", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:index_clause: %s", p, err)
		}
		if err := p.IndexClause.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.IndexClause, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:index_clause: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ColumnPredicate != nil {
		if err := oprot.WriteFieldBegin("column_predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column_predicate: %s", p, err)
		}
		if err := p.ColumnPredicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnPredicate, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column_predicate: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetIndexedSlicesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetIndexedSlicesArgs(%+v)", *p)
}

type GetIndexedSlicesResult struct {
	Success []*KeySlice              `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewGetIndexedSlicesResult() *GetIndexedSlicesResult {
	rval := &GetIndexedSlicesResult{}
	return rval
}

func (p *GetIndexedSlicesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*KeySlice, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem169 := NewKeySlice()
		if err := _elem169.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem169, err)
		}
		p.Success = append(p.Success, _elem169)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetIndexedSlicesResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_indexed_slices_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetIndexedSlicesResult(%+v)", *p)
}

type InsertArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Column           *Column          `thrift:"column,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewInsertArgs() *InsertArgs {
	rval := &InsertArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *InsertArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InsertArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *InsertArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *InsertArgs) readField3(iprot thrift.TProtocol) error {
	p.Column = NewColumn()
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column, err)
	}
	return nil
}

func (p *InsertArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *InsertArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("insert_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *InsertArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *InsertArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *InsertArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := p.Column.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Column, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *InsertArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *InsertArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InsertArgs(%+v)", *p)
}

type InsertResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewInsertResult() *InsertResult {
	rval := &InsertResult{}
	return rval
}

func (p *InsertResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InsertResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *InsertResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *InsertResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *InsertResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("insert_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *InsertResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *InsertResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *InsertResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *InsertResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InsertResult(%+v)", *p)
}

type AddArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Column           *CounterColumn   `thrift:"column,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewAddArgs() *AddArgs {
	rval := &AddArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *AddArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AddArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *AddArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *AddArgs) readField3(iprot thrift.TProtocol) error {
	p.Column = NewCounterColumn()
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column, err)
	}
	return nil
}

func (p *AddArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *AddArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("add_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AddArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *AddArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *AddArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := p.Column.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Column, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *AddArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *AddArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AddArgs(%+v)", *p)
}

type AddResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewAddResult() *AddResult {
	rval := &AddResult{}
	return rval
}

func (p *AddResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AddResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *AddResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *AddResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *AddResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("add_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AddResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *AddResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *AddResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *AddResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AddResult(%+v)", *p)
}

type RemoveArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnPath       *ColumnPath      `thrift:"column_path,2,required"`
	Timestamp        int64            `thrift:"timestamp,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4"`
}

func NewRemoveArgs() *RemoveArgs {
	rval := &RemoveArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *RemoveArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *RemoveArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnPath = NewColumnPath()
	if err := p.ColumnPath.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnPath, err)
	}
	return nil
}

func (p *RemoveArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *RemoveArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *RemoveArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *RemoveArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnPath != nil {
		if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_path: %s", p, err)
		}
		if err := p.ColumnPath.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnPath, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_path: %s", p, err)
		}
	}
	return err
}

func (p *RemoveArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *RemoveArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *RemoveArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveArgs(%+v)", *p)
}

type RemoveResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewRemoveResult() *RemoveResult {
	rval := &RemoveResult{}
	return rval
}

func (p *RemoveResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *RemoveResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *RemoveResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *RemoveResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveResult(%+v)", *p)
}

type RemoveCounterArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	Path             *ColumnPath      `thrift:"path,2,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required"`
}

func NewRemoveCounterArgs() *RemoveCounterArgs {
	rval := &RemoveCounterArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *RemoveCounterArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveCounterArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *RemoveCounterArgs) readField2(iprot thrift.TProtocol) error {
	p.Path = NewColumnPath()
	if err := p.Path.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Path, err)
	}
	return nil
}

func (p *RemoveCounterArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *RemoveCounterArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_counter_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveCounterArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Path != nil {
		if err := oprot.WriteFieldBegin("path", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:path: %s", p, err)
		}
		if err := p.Path.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Path, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:path: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:consistency_level: %s", p, err)
	}
	return err
}

func (p *RemoveCounterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveCounterArgs(%+v)", *p)
}

type RemoveCounterResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewRemoveCounterResult() *RemoveCounterResult {
	rval := &RemoveCounterResult{}
	return rval
}

func (p *RemoveCounterResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveCounterResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *RemoveCounterResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *RemoveCounterResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *RemoveCounterResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_counter_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveCounterResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveCounterResult(%+v)", *p)
}

type BatchMutateArgs struct {
	MutationMap      map[string]map[string][]*Mutation `thrift:"mutation_map,1,required"`
	ConsistencyLevel ConsistencyLevel                  `thrift:"consistency_level,2,required"`
}

func NewBatchMutateArgs() *BatchMutateArgs {
	rval := &BatchMutateArgs{
		ConsistencyLevel: 1,
	}
	return rval
}

func (p *BatchMutateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchMutateArgs) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string]map[string][]*Mutation, size)
	p.MutationMap = tMap
	for i := 0; i < size; i++ {
		var _key170 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key170 = v
		}
		_, _, size, err := iprot.ReadMapBegin()
		if err != nil {
			return fmt.Errorf("error reading map begin: %s")
		}
		tMap := make(map[string][]*Mutation, size)
		_val171 := tMap
		for i := 0; i < size; i++ {
			var _key172 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_key172 = v
			}
			_, size, err := iprot.ReadListBegin()
			if err != nil {
				return fmt.Errorf("error reading list begin: %s")
			}
			tSlice := make([]*Mutation, 0, size)
			_val173 := tSlice
			for i := 0; i < size; i++ {
				_elem174 := NewMutation()
				if err := _elem174.Read(iprot); err != nil {
					return fmt.Errorf("%T error reading struct: %s", _elem174, err)
				}
				_val173 = append(_val173, _elem174)
			}
			if err := iprot.ReadListEnd(); err != nil {
				return fmt.Errorf("error reading list end: %s")
			}
			_val171[_key172] = _val173
		}
		if err := iprot.ReadMapEnd(); err != nil {
			return fmt.Errorf("error reading map end: %s")
		}
		p.MutationMap[_key170] = _val171
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *BatchMutateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *BatchMutateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_mutate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.MutationMap != nil {
		if err := oprot.WriteFieldBegin("mutation_map", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:mutation_map: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.MAP, len(p.MutationMap)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.MutationMap {
			if err := oprot.WriteBinary([]byte(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(v)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range v {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
					return fmt.Errorf("error writing list begin: %s")
				}
				for _, v := range v {
					if err := v.Write(oprot); err != nil {
						return fmt.Errorf("%T error writing struct: %s", v, err)
					}
				}
				if err := oprot.WriteListEnd(); err != nil {
					return fmt.Errorf("error writing list end: %s")
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:mutation_map: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:consistency_level: %s", p, err)
	}
	return err
}

func (p *BatchMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchMutateArgs(%+v)", *p)
}

type BatchMutateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewBatchMutateResult() *BatchMutateResult {
	rval := &BatchMutateResult{}
	return rval
}

func (p *BatchMutateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchMutateResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *BatchMutateResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *BatchMutateResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *BatchMutateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_mutate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchMutateResult(%+v)", *p)
}

type TruncateArgs struct {
	Cfname string `thrift:"cfname,1,required"`
}

func NewTruncateArgs() *TruncateArgs {
	rval := &TruncateArgs{}
	return rval
}

func (p *TruncateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TruncateArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Cfname = v
	}
	return nil
}

func (p *TruncateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TruncateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfname", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cfname: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Cfname)); err != nil {
		return fmt.Errorf("%T.cfname (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cfname: %s", p, err)
	}
	return err
}

func (p *TruncateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateArgs(%+v)", *p)
}

type TruncateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewTruncateResult() *TruncateResult {
	rval := &TruncateResult{}
	return rval
}

func (p *TruncateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TruncateResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *TruncateResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *TruncateResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *TruncateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TruncateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *TruncateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *TruncateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *TruncateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateResult(%+v)", *p)
}

type DescribeSchemaVersionsArgs struct {
}

func NewDescribeSchemaVersionsArgs() *DescribeSchemaVersionsArgs {
	rval := &DescribeSchemaVersionsArgs{}
	return rval
}

func (p *DescribeSchemaVersionsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSchemaVersionsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_schema_versions_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSchemaVersionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSchemaVersionsArgs(%+v)", *p)
}

type DescribeSchemaVersionsResult struct {
	Success map[string][]string      `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeSchemaVersionsResult() *DescribeSchemaVersionsResult {
	rval := &DescribeSchemaVersionsResult{}
	return rval
}

func (p *DescribeSchemaVersionsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	tMap := make(map[string][]string, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key175 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key175 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s")
		}
		tSlice := make([]string, 0, size)
		_val176 := tSlice
		for i := 0; i < size; i++ {
			var _elem177 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_elem177 = v
			}
			_val176 = append(_val176, _elem177)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success[_key175] = _val176
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_schema_versions_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSchemaVersionsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSchemaVersionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSchemaVersionsResult(%+v)", *p)
}

type DescribeKeyspacesArgs struct {
}

func NewDescribeKeyspacesArgs() *DescribeKeyspacesArgs {
	rval := &DescribeKeyspacesArgs{}
	return rval
}

func (p *DescribeKeyspacesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspacesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspaces_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspacesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspacesArgs(%+v)", *p)
}

type DescribeKeyspacesResult struct {
	Success []*KsDef                 `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeKeyspacesResult() *DescribeKeyspacesResult {
	rval := &DescribeKeyspacesResult{}
	return rval
}

func (p *DescribeKeyspacesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspacesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*KsDef, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem178 := NewKsDef()
		if err := _elem178.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem178, err)
		}
		p.Success = append(p.Success, _elem178)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *DescribeKeyspacesResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeKeyspacesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspaces_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspacesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspacesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspacesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspacesResult(%+v)", *p)
}

type DescribeClusterNameArgs struct {
}

func NewDescribeClusterNameArgs() *DescribeClusterNameArgs {
	rval := &DescribeClusterNameArgs{}
	return rval
}

func (p *DescribeClusterNameArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeClusterNameArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_cluster_name_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeClusterNameArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeClusterNameArgs(%+v)", *p)
}

type DescribeClusterNameResult struct {
	Success string `thrift:"success,0"`
}

func NewDescribeClusterNameResult() *DescribeClusterNameResult {
	rval := &DescribeClusterNameResult{}
	return rval
}

func (p *DescribeClusterNameResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeClusterNameResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *DescribeClusterNameResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_cluster_name_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeClusterNameResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *DescribeClusterNameResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeClusterNameResult(%+v)", *p)
}

type DescribeVersionArgs struct {
}

func NewDescribeVersionArgs() *DescribeVersionArgs {
	rval := &DescribeVersionArgs{}
	return rval
}

func (p *DescribeVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_version_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeVersionArgs(%+v)", *p)
}

type DescribeVersionResult struct {
	Success string `thrift:"success,0"`
}

func NewDescribeVersionResult() *DescribeVersionResult {
	rval := &DescribeVersionResult{}
	return rval
}

func (p *DescribeVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeVersionResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *DescribeVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_version_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeVersionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *DescribeVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeVersionResult(%+v)", *p)
}

type DescribeRingArgs struct {
	Keyspace string `thrift:"keyspace,1,required"`
}

func NewDescribeRingArgs() *DescribeRingArgs {
	rval := &DescribeRingArgs{}
	return rval
}

func (p *DescribeRingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeRingArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *DescribeRingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_ring_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeRingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *DescribeRingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeRingArgs(%+v)", *p)
}

type DescribeRingResult struct {
	Success []*TokenRange            `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeRingResult() *DescribeRingResult {
	rval := &DescribeRingResult{}
	return rval
}

func (p *DescribeRingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeRingResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]*TokenRange, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem179 := NewTokenRange()
		if err := _elem179.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem179, err)
		}
		p.Success = append(p.Success, _elem179)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *DescribeRingResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeRingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_ring_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeRingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeRingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeRingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeRingResult(%+v)", *p)
}

type DescribePartitionerArgs struct {
}

func NewDescribePartitionerArgs() *DescribePartitionerArgs {
	rval := &DescribePartitionerArgs{}
	return rval
}

func (p *DescribePartitionerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribePartitionerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_partitioner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribePartitionerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribePartitionerArgs(%+v)", *p)
}

type DescribePartitionerResult struct {
	Success string `thrift:"success,0"`
}

func NewDescribePartitionerResult() *DescribePartitionerResult {
	rval := &DescribePartitionerResult{}
	return rval
}

func (p *DescribePartitionerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribePartitionerResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *DescribePartitionerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_partitioner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribePartitionerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *DescribePartitionerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribePartitionerResult(%+v)", *p)
}

type DescribeSnitchArgs struct {
}

func NewDescribeSnitchArgs() *DescribeSnitchArgs {
	rval := &DescribeSnitchArgs{}
	return rval
}

func (p *DescribeSnitchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSnitchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_snitch_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSnitchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSnitchArgs(%+v)", *p)
}

type DescribeSnitchResult struct {
	Success string `thrift:"success,0"`
}

func NewDescribeSnitchResult() *DescribeSnitchResult {
	rval := &DescribeSnitchResult{}
	return rval
}

func (p *DescribeSnitchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSnitchResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *DescribeSnitchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_snitch_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSnitchResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *DescribeSnitchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSnitchResult(%+v)", *p)
}

type DescribeKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required"`
}

func NewDescribeKeyspaceArgs() *DescribeKeyspaceArgs {
	rval := &DescribeKeyspaceArgs{}
	return rval
}

func (p *DescribeKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *DescribeKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *DescribeKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspaceArgs(%+v)", *p)
}

type DescribeKeyspaceResult struct {
	Success *KsDef                   `thrift:"success,0"`
	Nfe     *NotFoundException       `thrift:"nfe,1"`
	Ire     *InvalidRequestException `thrift:"ire,2"`
}

func NewDescribeKeyspaceResult() *DescribeKeyspaceResult {
	rval := &DescribeKeyspaceResult{}
	return rval
}

func (p *DescribeKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewKsDef()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Nfe = NewNotFoundException()
	if err := p.Nfe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Nfe, err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Nfe != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Nfe != nil {
		if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:nfe: %s", p, err)
		}
		if err := p.Nfe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Nfe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:nfe: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspaceResult(%+v)", *p)
}

type DescribeSplitsArgs struct {
	CfName       string `thrift:"cfName,1,required"`
	StartToken   string `thrift:"start_token,2,required"`
	EndToken     string `thrift:"end_token,3,required"`
	KeysPerSplit int32  `thrift:"keys_per_split,4,required"`
}

func NewDescribeSplitsArgs() *DescribeSplitsArgs {
	rval := &DescribeSplitsArgs{}
	return rval
}

func (p *DescribeSplitsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.CfName = v
	}
	return nil
}

func (p *DescribeSplitsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *DescribeSplitsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *DescribeSplitsArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.KeysPerSplit = v
	}
	return nil
}

func (p *DescribeSplitsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cfName: %s", p, err)
	}
	if err := oprot.WriteString(string(p.CfName)); err != nil {
		return fmt.Errorf("%T.cfName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cfName: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:start_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:end_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys_per_split", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:keys_per_split: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.KeysPerSplit)); err != nil {
		return fmt.Errorf("%T.keys_per_split (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:keys_per_split: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsArgs(%+v)", *p)
}

type DescribeSplitsResult struct {
	Success []string                 `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeSplitsResult() *DescribeSplitsResult {
	rval := &DescribeSplitsResult{}
	return rval
}

func (p *DescribeSplitsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]string, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem180 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem180 = v
		}
		p.Success = append(p.Success, _elem180)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *DescribeSplitsResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeSplitsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsResult(%+v)", *p)
}

type SystemAddColumnFamilyArgs struct {
	CfDef *CfDef `thrift:"cf_def,1,required"`
}

func NewSystemAddColumnFamilyArgs() *SystemAddColumnFamilyArgs {
	rval := &SystemAddColumnFamilyArgs{}
	return rval
}

func (p *SystemAddColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	p.CfDef = NewCfDef()
	if err := p.CfDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CfDef, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_column_family_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.CfDef != nil {
		if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:cf_def: %s", p, err)
		}
		if err := p.CfDef.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.CfDef, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:cf_def: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddColumnFamilyArgs(%+v)", *p)
}

type SystemAddColumnFamilyResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemAddColumnFamilyResult() *SystemAddColumnFamilyResult {
	rval := &SystemAddColumnFamilyResult{}
	return rval
}

func (p *SystemAddColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_column_family_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemAddColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddColumnFamilyResult(%+v)", *p)
}

type SystemDropColumnFamilyArgs struct {
	ColumnFamily string `thrift:"column_family,1,required"`
}

func NewSystemDropColumnFamilyArgs() *SystemDropColumnFamilyArgs {
	rval := &SystemDropColumnFamilyArgs{}
	return rval
}

func (p *SystemDropColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *SystemDropColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_column_family_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:column_family: %s", p, err)
	}
	return err
}

func (p *SystemDropColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropColumnFamilyArgs(%+v)", *p)
}

type SystemDropColumnFamilyResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemDropColumnFamilyResult() *SystemDropColumnFamilyResult {
	rval := &SystemDropColumnFamilyResult{}
	return rval
}

func (p *SystemDropColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_column_family_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemDropColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropColumnFamilyResult(%+v)", *p)
}

type SystemAddKeyspaceArgs struct {
	KsDef *KsDef `thrift:"ks_def,1,required"`
}

func NewSystemAddKeyspaceArgs() *SystemAddKeyspaceArgs {
	rval := &SystemAddKeyspaceArgs{}
	return rval
}

func (p *SystemAddKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	p.KsDef = NewKsDef()
	if err := p.KsDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.KsDef, err)
	}
	return nil
}

func (p *SystemAddKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.KsDef != nil {
		if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ks_def: %s", p, err)
		}
		if err := p.KsDef.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.KsDef, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ks_def: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddKeyspaceArgs(%+v)", *p)
}

type SystemAddKeyspaceResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemAddKeyspaceResult() *SystemAddKeyspaceResult {
	rval := &SystemAddKeyspaceResult{}
	return rval
}

func (p *SystemAddKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemAddKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemAddKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddKeyspaceResult(%+v)", *p)
}

type SystemDropKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required"`
}

func NewSystemDropKeyspaceArgs() *SystemDropKeyspaceArgs {
	rval := &SystemDropKeyspaceArgs{}
	return rval
}

func (p *SystemDropKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *SystemDropKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *SystemDropKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropKeyspaceArgs(%+v)", *p)
}

type SystemDropKeyspaceResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemDropKeyspaceResult() *SystemDropKeyspaceResult {
	rval := &SystemDropKeyspaceResult{}
	return rval
}

func (p *SystemDropKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemDropKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemDropKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropKeyspaceResult(%+v)", *p)
}

type SystemUpdateKeyspaceArgs struct {
	KsDef *KsDef `thrift:"ks_def,1,required"`
}

func NewSystemUpdateKeyspaceArgs() *SystemUpdateKeyspaceArgs {
	rval := &SystemUpdateKeyspaceArgs{}
	return rval
}

func (p *SystemUpdateKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	p.KsDef = NewKsDef()
	if err := p.KsDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.KsDef, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.KsDef != nil {
		if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ks_def: %s", p, err)
		}
		if err := p.KsDef.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.KsDef, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ks_def: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateKeyspaceArgs(%+v)", *p)
}

type SystemUpdateKeyspaceResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemUpdateKeyspaceResult() *SystemUpdateKeyspaceResult {
	rval := &SystemUpdateKeyspaceResult{}
	return rval
}

func (p *SystemUpdateKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemUpdateKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateKeyspaceResult(%+v)", *p)
}

type SystemUpdateColumnFamilyArgs struct {
	CfDef *CfDef `thrift:"cf_def,1,required"`
}

func NewSystemUpdateColumnFamilyArgs() *SystemUpdateColumnFamilyArgs {
	rval := &SystemUpdateColumnFamilyArgs{}
	return rval
}

func (p *SystemUpdateColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	p.CfDef = NewCfDef()
	if err := p.CfDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CfDef, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_column_family_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.CfDef != nil {
		if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:cf_def: %s", p, err)
		}
		if err := p.CfDef.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.CfDef, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:cf_def: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateColumnFamilyArgs(%+v)", *p)
}

type SystemUpdateColumnFamilyResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemUpdateColumnFamilyResult() *SystemUpdateColumnFamilyResult {
	rval := &SystemUpdateColumnFamilyResult{}
	return rval
}

func (p *SystemUpdateColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_column_family_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemUpdateColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateColumnFamilyResult(%+v)", *p)
}

type ExecuteCqlQueryArgs struct {
	Query       []byte      `thrift:"query,1,required"`
	Compression Compression `thrift:"compression,2,required"`
}

func NewExecuteCqlQueryArgs() *ExecuteCqlQueryArgs {
	rval := &ExecuteCqlQueryArgs{}
	return rval
}

func (p *ExecuteCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Query != nil {
		if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Query); err != nil {
			return fmt.Errorf("%T.query (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:query: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return fmt.Errorf("%T.compression (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
	}
	return err
}

func (p *ExecuteCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCqlQueryArgs(%+v)", *p)
}

type ExecuteCqlQueryResult struct {
	Success *CqlResult                   `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Ue      *UnavailableException        `thrift:"ue,2"`
	Te      *TimedOutException           `thrift:"te,3"`
	Sde     *SchemaDisagreementException `thrift:"sde,4"`
}

func NewExecuteCqlQueryResult() *ExecuteCqlQueryResult {
	rval := &ExecuteCqlQueryResult{}
	return rval
}

func (p *ExecuteCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewCqlResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCqlQueryResult(%+v)", *p)
}

type PrepareCqlQueryArgs struct {
	Query       []byte      `thrift:"query,1,required"`
	Compression Compression `thrift:"compression,2,required"`
}

func NewPrepareCqlQueryArgs() *PrepareCqlQueryArgs {
	rval := &PrepareCqlQueryArgs{}
	return rval
}

func (p *PrepareCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCqlQueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *PrepareCqlQueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *PrepareCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Query != nil {
		if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Query); err != nil {
			return fmt.Errorf("%T.query (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:query: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return fmt.Errorf("%T.compression (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
	}
	return err
}

func (p *PrepareCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCqlQueryArgs(%+v)", *p)
}

type PrepareCqlQueryResult struct {
	Success *CqlPreparedResult       `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewPrepareCqlQueryResult() *PrepareCqlQueryResult {
	rval := &PrepareCqlQueryResult{}
	return rval
}

func (p *PrepareCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewCqlPreparedResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCqlQueryResult(%+v)", *p)
}

type ExecutePreparedCqlQueryArgs struct {
	ItemId int32    `thrift:"itemId,1,required"`
	Values []string `thrift:"values,2,required"`
}

func NewExecutePreparedCqlQueryArgs() *ExecutePreparedCqlQueryArgs {
	rval := &ExecutePreparedCqlQueryArgs{}
	return rval
}

func (p *ExecutePreparedCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s")
	}
	tSlice := make([]string, 0, size)
	p.Values = tSlice
	for i := 0; i < size; i++ {
		var _elem181 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem181 = v
		}
		p.Values = append(p.Values, _elem181)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:itemId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return fmt.Errorf("%T.itemId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:itemId: %s", p, err)
	}
	return err
}

func (p *ExecutePreparedCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Values != nil {
		if err := oprot.WriteFieldBegin("values", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:values: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Values)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Values {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:values: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCqlQueryArgs(%+v)", *p)
}

type ExecutePreparedCqlQueryResult struct {
	Success *CqlResult                   `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Ue      *UnavailableException        `thrift:"ue,2"`
	Te      *TimedOutException           `thrift:"te,3"`
	Sde     *SchemaDisagreementException `thrift:"sde,4"`
}

func NewExecutePreparedCqlQueryResult() *ExecutePreparedCqlQueryResult {
	rval := &ExecutePreparedCqlQueryResult{}
	return rval
}

func (p *ExecutePreparedCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewCqlResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCqlQueryResult(%+v)", *p)
}
